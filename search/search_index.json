{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Overview","text":"<p>THEMAP is a python library designed for aiding in drug discovery by providing powerful methods for estimating the hardness of bioactivity prediction task for transfer learning. It enables researchers and chemists to efficiently determine transferrabilty map for bioactivity prediction tasks. </p>"},{"location":"index.html#installation","title":"Installation","text":"<p><code>THEMAP</code> can be installed using pip. First, clone this repository, create a new conda environment with the required packages, and finally, install the repository using pip.</p> <pre><code>conda env create -f environment.yml\nconda activate themap\n\npip install --no-deps git+https://github.com/HFooladi/otdd.git  \npip install --no-deps -e .\n</code></pre>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>You can calculate distance between chemical spces of two (or more) datasets using <code>MoleculeDatasetDistance</code> class.</p> <pre><code>import os\nfrom dpu_utils.utils.richpath import RichPath\n\nfrom themap.data import MoleculeDataset\nfrom themap.data.distance import MoleculeDatasetDistance\n\nsource_dataset_path = RichPath.create(os.path.join(\"datasets\", \"train\", \"CHEMBL1023359.jsonl.gz\"))\ntarget_dataset_path = RichPath.create(os.path.join(\"datasets\", \"test\", \"CHEMBL2219358.jsonl.gz\"))\n\n# load some datasets\nsource_dataset = MoleculeDataset.load_from_file(source_dataset_path)\ntarget_dataset = MoleculeDataset.load_from_file(target_dataset_path)\n\n# get the features\nmolecule_feaurizer = \"gin_supervised_infomax\"\nsource_features = source_dataset.get_dataset_embedding(molecule_feaurizer)\ntarget_features = target_dataset.get_dataset_embedding(molecule_feaurizer)\n\n# calculate the distance\nDist = MoleculeDatasetDistance(D1=source_dataset, D2=target_dataset, method=\"otdd\")\nDist.get_distance()\n&gt;&gt;&gt; {'CHEMBL2219358': {'CHEMBL1023359': 7.074298858642578}}\n</code></pre> <p>You can calculate distance between protein spces of two (or more) proteins (metadata) using <code>ProteinDatasetDistance</code> class.</p> <pre><code>from themap.data import ProteinDataset\nfrom themap.data.distance import ProteinDatasetDistance\n\n# load some datasets\nsource_protein = ProteinDataset.load_from_file(\"datasets/train/train_proteins.fasta\")\nsource_protein = ProteinDataset.load_from_file(\"datasets/train/train_proteins.fasta\")\n\n# get the features\nprotein_featurizer = \"esm2_t33_650M_UR50D\"\nsource_protein_features = source_protein.get_features(protein_featurizer)\ntarget_protein_features = target_protein.get_features(protein_featurizer)\n\n# calculate the distance\nDist = ProteinDatasetDistance(source_protein, target_protein, \"euclidean\")\nDist.get_distance()\n&gt;&gt;&gt; {'CHEMBL2219236': {'CHEMBL2219236': 2.9516282297179703,\n&gt;&gt;&gt;  'CHEMBL2219358': 4.372332083302979,\n&gt;&gt;&gt;  'CHEMBL1963831': 4.258244298189887},\n&gt;&gt;&gt;  'CHEMBL2219358': {'CHEMBL2219236': 3.560959265946417,\n&gt;&gt;&gt;  'CHEMBL2219358': 2.005268985065835,\n&gt;&gt;&gt;  'CHEMBL1963831': 2.772209146380105},\n&gt;&gt;&gt;  'CHEMBL1963831': {'CHEMBL2219236': 3.3623606434721895,\n&gt;&gt;&gt;  'CHEMBL2219358': 1.9580669485355773,\n&gt;&gt;&gt;  'CHEMBL1963831': 2.452369399042511}}\n</code></pre>"},{"location":"index.html#tutorials","title":"Tutorials","text":"<p>Check out the tutorials to get started.</p>"},{"location":"tutorials/Basics.html","title":"Importing Required Libraries","text":"In\u00a0[1]: Copied! <pre>#import general packages\nimport os\nimport argparse\nimport logging\nimport sys\nfrom typing import Dict, List\nfrom dpu_utils.utils.richpath import RichPath\nimport pickle\n\nimport torch\nfrom tqdm.notebook import tqdm\nimport pandas as pd\n\n# Setting up local details:\n# This should be the location of the checkout of the THEMAP repository:\nrepo_path = os.path.dirname(os.path.abspath(\"\"))\nCHECKOUT_PATH = repo_path\nDATASET_PATH = os.path.join(repo_path, \"datasets\")\n\nos.chdir(CHECKOUT_PATH)\nsys.path.insert(0, CHECKOUT_PATH)\n</pre> #import general packages import os import argparse import logging import sys from typing import Dict, List from dpu_utils.utils.richpath import RichPath import pickle  import torch from tqdm.notebook import tqdm import pandas as pd  # Setting up local details: # This should be the location of the checkout of the THEMAP repository: repo_path = os.path.dirname(os.path.abspath(\"\")) CHECKOUT_PATH = repo_path DATASET_PATH = os.path.join(repo_path, \"datasets\")  os.chdir(CHECKOUT_PATH) sys.path.insert(0, CHECKOUT_PATH) In\u00a0[2]: Copied! <pre>from third_party.otdd.otdd.pytorch.datasets import MolDataset, load_molecule_data\nfrom third_party.otdd.otdd.pytorch.distance import DatasetDistance\n</pre> from third_party.otdd.otdd.pytorch.datasets import MolDataset, load_molecule_data from third_party.otdd.otdd.pytorch.distance import DatasetDistance <pre>ot.gpu not found - coupling computation will be in cpu\n</pre> In\u00a0[3]: Copied! <pre># import visualization packages\n%matplotlib inline\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nimport seaborn as sns\nfrom sklearn.manifold import TSNE\nimport pandas as pd\nfrom themap.utils import compute_task_hardness_from_distance_matrix, normalize, internal_hardness, otdd_hardness\nfrom themap.data import MoleculeDatapoint, MoleculeDataset, ProteinDataset\n\n\nlight_color = plt.get_cmap(\"plasma\").colors[170]\ndark_color = \"black\"\n\nmatplotlib.rcParams.update(\n    {\n        \"pgf.texsystem\": \"pdflatex\",\n        \"font.family\": \"serif\",\n        \"font.serif\": \"Computer Modern Roman\",\n        \"font.size\": 20,\n        \"text.usetex\": True,\n        \"pgf.rcfonts\": False,\n    }\n)\n</pre> # import visualization packages %matplotlib inline  import matplotlib import matplotlib.pyplot as plt import ipywidgets as widgets import seaborn as sns from sklearn.manifold import TSNE import pandas as pd from themap.utils import compute_task_hardness_from_distance_matrix, normalize, internal_hardness, otdd_hardness from themap.data import MoleculeDatapoint, MoleculeDataset, ProteinDataset   light_color = plt.get_cmap(\"plasma\").colors[170] dark_color = \"black\"  matplotlib.rcParams.update(     {         \"pgf.texsystem\": \"pdflatex\",         \"font.family\": \"serif\",         \"font.serif\": \"Computer Modern Roman\",         \"font.size\": 20,         \"text.usetex\": True,         \"pgf.rcfonts\": False,     } ) In\u00a0[4]: Copied! <pre>source_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"train\", \"CHEMBL1023359.jsonl.gz\"))\ntarget_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"test\", \"CHEMBL2219358.jsonl.gz\"))\n\nsource_dataset = MoleculeDataset.load_from_file(source_dataset_path)\ntarget_dataset = MoleculeDataset.load_from_file(target_dataset_path)\n</pre> source_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"train\", \"CHEMBL1023359.jsonl.gz\")) target_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"test\", \"CHEMBL2219358.jsonl.gz\"))  source_dataset = MoleculeDataset.load_from_file(source_dataset_path) target_dataset = MoleculeDataset.load_from_file(target_dataset_path) In\u00a0[5]: Copied! <pre>Molecule_Feaurizer = widgets.Dropdown(\n    options=['gin_supervised_infomax', 'gin_supervised_masking', 'gin_supervised_edgepred'],\n    value='gin_supervised_infomax',\n    description='Molecule Featurizer:',\n    disabled=False,\n)\n</pre> Molecule_Feaurizer = widgets.Dropdown(     options=['gin_supervised_infomax', 'gin_supervised_masking', 'gin_supervised_edgepred'],     value='gin_supervised_infomax',     description='Molecule Featurizer:',     disabled=False, ) In\u00a0[6]: Copied! <pre>Molecule_Feaurizer\n</pre> Molecule_Feaurizer Out[6]: <pre>Dropdown(description='Molecule Featurizer:', options=('gin_supervised_infomax', 'gin_supervised_masking', 'gin\u2026</pre> In\u00a0[7]: Copied! <pre>## compute and load the embeddings\nmolecule_feaurizer = Molecule_Feaurizer.value\nsource_features = source_dataset.get_dataset_embedding(molecule_feaurizer)\ntarget_features = target_dataset.get_dataset_embedding(molecule_feaurizer)\nassert source_features.shape[1] == target_features.shape[1]\n</pre> ## compute and load the embeddings molecule_feaurizer = Molecule_Feaurizer.value source_features = source_dataset.get_dataset_embedding(molecule_feaurizer) target_features = target_dataset.get_dataset_embedding(molecule_feaurizer) assert source_features.shape[1] == target_features.shape[1] In\u00a0[8]: Copied! <pre>source_dataset_otdd = MolDataset(source_dataset)\ntarget_dataset_otdd = MolDataset(target_dataset)\n</pre> source_dataset_otdd = MolDataset(source_dataset) target_dataset_otdd = MolDataset(target_dataset) In\u00a0[9]: Copied! <pre>source_dataset_loader = load_molecule_data(source_dataset)\ntarget_dataset_loader = load_molecule_data(target_dataset)\n</pre> source_dataset_loader = load_molecule_data(source_dataset) target_dataset_loader = load_molecule_data(target_dataset) In\u00a0[\u00a0]: Copied! <pre># Instantiate distance\ndist = DatasetDistance(source_dataset_loader, target_dataset_loader,\n                       inner_ot_method = 'exact',\n                       debiased_loss = True,\n                       p = 2, entreg = 1e-1,\n                       device='cuda' if torch.cuda.is_available() else 'cpu')\n\nd = dist.distance(maxsamples = 1000)\nprint(f'OTDD(src,tgt)={d}')\n</pre> # Instantiate distance dist = DatasetDistance(source_dataset_loader, target_dataset_loader,                        inner_ot_method = 'exact',                        debiased_loss = True,                        p = 2, entreg = 1e-1,                        device='cuda' if torch.cuda.is_available() else 'cpu')  d = dist.distance(maxsamples = 1000) print(f'OTDD(src,tgt)={d}') In\u00a0[\u00a0]: Copied! <pre>import glob\nsource_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"train\", \"CHEMBL*\"))\ntarget_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"test\", \"CHEMBL*\"))\nchem_distances = {}\nfor target_path in tqdm(target_datasets_path):\n    chem_distance = {}\n    target_dataset_path = RichPath.create(target_path)\n    target_dataset = MoleculeDataset.load_from_file(target_dataset_path)\n    target_features = target_dataset.get_dataset_embedding(molecule_feaurizer)\n    target_dataset_otdd = MolDataset(target_dataset)\n    target_dataset_loader = load_molecule_data(target_dataset)\n    for source_path in source_datasets_path:\n        source_dataset_path = RichPath.create(source_path)\n        source_dataset = MoleculeDataset.load_from_file(source_dataset_path)\n        source_features = source_dataset.get_dataset_embedding(molecule_feaurizer)\n        source_dataset_otdd = MolDataset(source_dataset)\n        source_dataset_loader = load_molecule_data(source_dataset)\n\n        dist = DatasetDistance(source_dataset_loader, target_dataset_loader,\n                               inner_ot_method = 'exact',\n                               debiased_loss = True,\n                               p = 2, entreg = 1e-1,\n                               device='cuda' if torch.cuda.is_available() else 'cpu')\n        \n        d = dist.distance(maxsamples = 1000)\n        print(f'OTDD({source_dataset.task_id},{target_dataset.task_id})= {d}')\n        chem_distance[source_dataset.task_id] = d.cpu().item()\n    chem_distances[target_dataset.task_id] = chem_distance\n</pre> import glob source_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"train\", \"CHEMBL*\")) target_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"test\", \"CHEMBL*\")) chem_distances = {} for target_path in tqdm(target_datasets_path):     chem_distance = {}     target_dataset_path = RichPath.create(target_path)     target_dataset = MoleculeDataset.load_from_file(target_dataset_path)     target_features = target_dataset.get_dataset_embedding(molecule_feaurizer)     target_dataset_otdd = MolDataset(target_dataset)     target_dataset_loader = load_molecule_data(target_dataset)     for source_path in source_datasets_path:         source_dataset_path = RichPath.create(source_path)         source_dataset = MoleculeDataset.load_from_file(source_dataset_path)         source_features = source_dataset.get_dataset_embedding(molecule_feaurizer)         source_dataset_otdd = MolDataset(source_dataset)         source_dataset_loader = load_molecule_data(source_dataset)          dist = DatasetDistance(source_dataset_loader, target_dataset_loader,                                inner_ot_method = 'exact',                                debiased_loss = True,                                p = 2, entreg = 1e-1,                                device='cuda' if torch.cuda.is_available() else 'cpu')                  d = dist.distance(maxsamples = 1000)         print(f'OTDD({source_dataset.task_id},{target_dataset.task_id})= {d}')         chem_distance[source_dataset.task_id] = d.cpu().item()     chem_distances[target_dataset.task_id] = chem_distance  In\u00a0[12]: Copied! <pre>## Choose your target from chem_distances.keys()\nyour_tasks = \"CHEMBL2219236\"\nchem_dist = chem_distances[your_tasks]\nfig = plt.figure(figsize=(12, 5))\nplt.bar(chem_dist.keys(), chem_dist.values())\nplt.xlabel('Source datasets')\nplt.ylabel('OTDD')\nplt.title(f'OTDD between source datasets and target {your_tasks}')\nplt.xticks(rotation=90)\nplt.grid(axis='y', linestyle='--', alpha=1.0)\nplt.show()\n</pre> ## Choose your target from chem_distances.keys() your_tasks = \"CHEMBL2219236\" chem_dist = chem_distances[your_tasks] fig = plt.figure(figsize=(12, 5)) plt.bar(chem_dist.keys(), chem_dist.values()) plt.xlabel('Source datasets') plt.ylabel('OTDD') plt.title(f'OTDD between source datasets and target {your_tasks}') plt.xticks(rotation=90) plt.grid(axis='y', linestyle='--', alpha=1.0) plt.show() In\u00a0[15]: Copied! <pre>chem_distances.keys()\n</pre> chem_distances.keys() Out[15]: <pre>dict_keys(['CHEMBL2219236', 'CHEMBL1963831', 'CHEMBL2219358'])</pre> In\u00a0[13]: Copied! <pre>Protein_Feaurizer = widgets.Dropdown(\n    options=['esm2_t6_8M_UR50D', 'esm2_t12_35M_UR50D', 'esm2_t30_150M_UR50D', 'esm2_t33_650M_UR50D', 'esm2_t36_3B_UR50D'],\n    value='esm2_t33_650M_UR50D',\n    description='Protein Featurizer:',\n    disabled=False,\n)\n</pre> Protein_Feaurizer = widgets.Dropdown(     options=['esm2_t6_8M_UR50D', 'esm2_t12_35M_UR50D', 'esm2_t30_150M_UR50D', 'esm2_t33_650M_UR50D', 'esm2_t36_3B_UR50D'],     value='esm2_t33_650M_UR50D',     description='Protein Featurizer:',     disabled=False, ) In\u00a0[14]: Copied! <pre>Protein_Feaurizer\n</pre> Protein_Feaurizer Out[14]: <pre>Dropdown(description='Protein Featurizer:', index=3, options=('esm2_t6_8M_UR50D', 'esm2_t12_35M_UR50D', 'esm2_\u2026</pre> In\u00a0[15]: Copied! <pre>source_protein = ProteinDataset.load_from_file(\"datasets/train/train_proteins.fasta\")\ntarget_protein = ProteinDataset.load_from_file(\"datasets/test/test_proteins.fasta\")\n</pre> source_protein = ProteinDataset.load_from_file(\"datasets/train/train_proteins.fasta\") target_protein = ProteinDataset.load_from_file(\"datasets/test/test_proteins.fasta\") In\u00a0[16]: Copied! <pre>protein_featurizer = Protein_Feaurizer.value\nsource_protein_features = source_protein.get_features(protein_featurizer)\ntarget_protein_features = target_protein.get_features(protein_featurizer)\n</pre> protein_featurizer = Protein_Feaurizer.value source_protein_features = source_protein.get_features(protein_featurizer) target_protein_features = target_protein.get_features(protein_featurizer) In\u00a0[17]: Copied! <pre>from scipy.spatial.distance import cdist\ndist = cdist(source_protein.features, target_protein.features)\n</pre> from scipy.spatial.distance import cdist dist = cdist(source_protein.features, target_protein.features) In\u00a0[18]: Copied! <pre>prot_distances = {}\nfor i, target_prot in enumerate(target_protein.task_id):\n    prot_distance = {}\n    for j, source_prot in enumerate(source_protein.task_id):\n        prot_distance[source_prot] = dist[j, i]\n    prot_distances[target_prot] = prot_distance\n</pre> prot_distances = {} for i, target_prot in enumerate(target_protein.task_id):     prot_distance = {}     for j, source_prot in enumerate(source_protein.task_id):         prot_distance[source_prot] = dist[j, i]     prot_distances[target_prot] = prot_distance In\u00a0[24]: Copied! <pre>## Choose your target from chem_distances.keys()\nyour_tasks = \"CHEMBL2219236\"\nprot_dist = prot_distances[your_tasks]\nfig = plt.figure(figsize=(12, 5))\nplt.bar(prot_dist.keys(), prot_dist.values())\nplt.xlabel('Source datasets')\nplt.ylabel('Protein Distance')\nplt.title(f'Protein Distance between source datasets and target {your_tasks}')\nplt.xticks(rotation=90)\nplt.grid(axis='y', linestyle='--', alpha=1.0)\nplt.show()\n</pre> ## Choose your target from chem_distances.keys() your_tasks = \"CHEMBL2219236\" prot_dist = prot_distances[your_tasks] fig = plt.figure(figsize=(12, 5)) plt.bar(prot_dist.keys(), prot_dist.values()) plt.xlabel('Source datasets') plt.ylabel('Protein Distance') plt.title(f'Protein Distance between source datasets and target {your_tasks}') plt.xticks(rotation=90) plt.grid(axis='y', linestyle='--', alpha=1.0) plt.show() <p>Now, we can answer to the following questions:</p> <ul> <li>Given a target task, what is the closest source task in terms of chemical and protein distances?</li> <li>Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space?</li> <li>Given a target task and source tasks, how to pick the k nearset source tasks fo transfer learning?</li> </ul> <p>So, let's answer to this questions in the following sections.</p> In\u00a0[42]: Copied! <pre>chem_df = pd.DataFrame.from_dict(chem_distances)\nprot_df = pd.DataFrame.from_dict(prot_distances)\n</pre> chem_df = pd.DataFrame.from_dict(chem_distances) prot_df = pd.DataFrame.from_dict(prot_distances) In\u00a0[69]: Copied! <pre>## Given a target task, what is the closest source task in terms of chemical and protein distances?\nyour_task = \"CHEMBL2219236\"\n\nchem_distance = chem_df[your_task]\nprot_distance = prot_df[your_task]\n\nnormalized_chem_distance=(chem_distance-chem_distance.min())/(chem_distance.max()-chem_distance.min())\nnormalized_prot_distance=(prot_distance-prot_distance.min())/(prot_distance.max()-prot_distance.min())\nnormalized_prot_distance = normalized_prot_distance.reindex(normalized_chem_distance.index)\nnormalized_comb_distance = (normalized_chem_distance + normalized_prot_distance)/2\n\n\nprint(f'Closest source task in terms of chemical distance: {chem_distance.idxmin()}')\nprint(f'Closest source task in terms of protein distance: {prot_distance.idxmin()}')\nprint(f'Closest source task in terms of combination of chemical and protein distance: {normalized_comb_distance.idxmin()}')\n</pre> ## Given a target task, what is the closest source task in terms of chemical and protein distances? your_task = \"CHEMBL2219236\"  chem_distance = chem_df[your_task] prot_distance = prot_df[your_task]  normalized_chem_distance=(chem_distance-chem_distance.min())/(chem_distance.max()-chem_distance.min()) normalized_prot_distance=(prot_distance-prot_distance.min())/(prot_distance.max()-prot_distance.min()) normalized_prot_distance = normalized_prot_distance.reindex(normalized_chem_distance.index) normalized_comb_distance = (normalized_chem_distance + normalized_prot_distance)/2   print(f'Closest source task in terms of chemical distance: {chem_distance.idxmin()}') print(f'Closest source task in terms of protein distance: {prot_distance.idxmin()}') print(f'Closest source task in terms of combination of chemical and protein distance: {normalized_comb_distance.idxmin()}') <pre>Closest source task in terms of chemical distance: CHEMBL2218944\nClosest source task in terms of protein distance: CHEMBL2219012\nClosest source task in terms of combination of chemical and protein distance: CHEMBL2219012\n</pre> In\u00a0[91]: Copied! <pre>## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space?\n## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks.\nk = 3\n\ntarget_tasks = chem_df.columns\nsource_tasks = chem_df.index\n\nhardness_all={}\nfor target_task in target_tasks:\n    hardness={}\n    chem_distance = chem_df[target_task]\n    prot_distance = prot_df[target_task]\n\n    chem_distance=chem_distance.sort_values()\n    prot_distance = prot_distance.sort_values()\n\n    hardness['EXT_CHEM'] = chem_distance[:k].sum()/k\n    hardness['EXT_PROT'] = prot_distance[:k].sum()/k\n\n    hardness_all[target_task] = hardness\n\nhardness_df = pd.DataFrame.from_dict(hardness_all).T\nhardness_df['all'] = (hardness_df['EXT_CHEM'] + hardness_df['EXT_PROT'])/2\n\nprint(f'Easiest target task in terms of chemical distance: {hardness_df[\"EXT_CHEM\"].idxmin()}')\nprint(f'Easiest target task in terms of protein distance: {hardness_df[\"EXT_PROT\"].idxmin()}')\nprint(f'Easiest target task in terms of combination of chemical and protein distance: {hardness_df[\"all\"].idxmin()}')\n</pre> ## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space? ## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks. k = 3  target_tasks = chem_df.columns source_tasks = chem_df.index  hardness_all={} for target_task in target_tasks:     hardness={}     chem_distance = chem_df[target_task]     prot_distance = prot_df[target_task]      chem_distance=chem_distance.sort_values()     prot_distance = prot_distance.sort_values()      hardness['EXT_CHEM'] = chem_distance[:k].sum()/k     hardness['EXT_PROT'] = prot_distance[:k].sum()/k      hardness_all[target_task] = hardness  hardness_df = pd.DataFrame.from_dict(hardness_all).T hardness_df['all'] = (hardness_df['EXT_CHEM'] + hardness_df['EXT_PROT'])/2  print(f'Easiest target task in terms of chemical distance: {hardness_df[\"EXT_CHEM\"].idxmin()}') print(f'Easiest target task in terms of protein distance: {hardness_df[\"EXT_PROT\"].idxmin()}') print(f'Easiest target task in terms of combination of chemical and protein distance: {hardness_df[\"all\"].idxmin()}') <pre>Easiest target task in terms of chemical distance: CHEMBL2219236\nEasiest target task in terms of protein distance: CHEMBL2219358\nEasiest target task in terms of combination of chemical and protein distance: CHEMBL2219358\n</pre> In\u00a0[93]: Copied! <pre>plt.figure(figsize=(12, 5))\nplt.bar(hardness_df.index, hardness_df['all'])\nplt.xlabel('Target datasets')\nplt.ylabel('Hardness')\nplt.title(f'Hardness of target datasets')\nplt.xticks(rotation=90)\nplt.grid(axis='y', linestyle='--', alpha=1.0)\nplt.show()\n</pre> plt.figure(figsize=(12, 5)) plt.bar(hardness_df.index, hardness_df['all']) plt.xlabel('Target datasets') plt.ylabel('Hardness') plt.title(f'Hardness of target datasets') plt.xticks(rotation=90) plt.grid(axis='y', linestyle='--', alpha=1.0) plt.show() In\u00a0[103]: Copied! <pre>## Given a target task and source tasks, how to pick the k nearset source tasks fo transfer learning?\n## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space?\n## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks.\nk = 3\n\ntarget_tasks = chem_df.columns\nsource_tasks = chem_df.index\n\nclosest_tasks={}\nfor target_task in target_tasks:\n    closest={}\n    chem_distance = chem_df[target_task]\n    prot_distance = prot_df[target_task]\n\n    chem_distance=chem_distance.sort_values()\n    prot_distance = prot_distance.sort_values()\n\n    closest['EXT_CHEM'] = chem_distance[:k].index.to_list()\n    closest['EXT_PROT'] = prot_distance[:k].index.to_list()\n\n    closest_tasks[target_task] = closest\n\nclosest_df = pd.DataFrame.from_dict(closest_tasks).T\n</pre> ## Given a target task and source tasks, how to pick the k nearset source tasks fo transfer learning? ## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space? ## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks. k = 3  target_tasks = chem_df.columns source_tasks = chem_df.index  closest_tasks={} for target_task in target_tasks:     closest={}     chem_distance = chem_df[target_task]     prot_distance = prot_df[target_task]      chem_distance=chem_distance.sort_values()     prot_distance = prot_distance.sort_values()      closest['EXT_CHEM'] = chem_distance[:k].index.to_list()     closest['EXT_PROT'] = prot_distance[:k].index.to_list()      closest_tasks[target_task] = closest  closest_df = pd.DataFrame.from_dict(closest_tasks).T"},{"location":"tutorials/Basics.html#importing-required-libraries","title":"Importing Required Libraries\u00b6","text":"<p>First, we are importing the libraries and modules that are required for running this notebook.</p>"},{"location":"tutorials/Basics.html#create-source-and-target-datasets-data","title":"Create source and target datasets (Data)\u00b6","text":""},{"location":"tutorials/Basics.html#calculate-chemcial-distance-between-target-datasets-with-all-the-source-datasets","title":"Calculate chemcial distance between target datasets with all the source datasets\u00b6","text":""},{"location":"tutorials/Basics.html#calculate-protein-distance-between-target-datasets-with-all-the-source-datasets","title":"Calculate protein distance between target datasets with all the source datasets\u00b6","text":""},{"location":"tutorials/Basics.html#combine-two-distances","title":"Combine Two Distances\u00b6","text":""}]}