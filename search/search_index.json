{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Overview","text":"<p><code>THEMAP</code> is a python library designed for aiding in drug discovery by providing powerful methods for estimating the hardness of bioactivity prediction task for transfer learning. It enables researchers and chemists to efficiently determine transferrabilty map for bioactivity prediction tasks. </p>"},{"location":"index.html#installation","title":"Installation","text":"<p><code>THEMAP</code> can be installed using pip. First, clone this repository, create a new conda environment with the required packages, and finally, install the repository using pip.</p> <pre><code>conda env create -f environment.yml\nconda activate themap\n\npip install --no-deps git+https://github.com/HFooladi/otdd.git  \npip install --no-deps -e .\n</code></pre>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>You can calculate distance between chemical spces of two (or more) datasets using <code>MoleculeDatasetDistance</code> class.</p> <pre><code>import os\nfrom dpu_utils.utils.richpath import RichPath\n\nfrom themap.data import MoleculeDataset\nfrom themap.distance import MoleculeDatasetDistance\n\nsource_dataset_path = RichPath.create(os.path.join(\"datasets\", \"train\", \"CHEMBL1023359.jsonl.gz\"))\ntarget_dataset_path = RichPath.create(os.path.join(\"datasets\", \"test\", \"CHEMBL2219358.jsonl.gz\"))\n\n# load some datasets\nsource_dataset = MoleculeDataset.load_from_file(source_dataset_path)\ntarget_dataset = MoleculeDataset.load_from_file(target_dataset_path)\n\n# get the features\nmolecule_feaurizer = \"gin_supervised_infomax\"\nsource_features = source_dataset.get_dataset_embedding(molecule_feaurizer)\ntarget_features = target_dataset.get_dataset_embedding(molecule_feaurizer)\n\n# calculate the distance\nDist = MoleculeDatasetDistance(D1=source_dataset, D2=target_dataset, method=\"otdd\")\nDist.get_distance()\n# {'CHEMBL2219358': {'CHEMBL1023359': 7.074298858642578}}\n</code></pre> <p>You can calculate distance between protein spces of two (or more) proteins (metadata) using <code>ProteinDatasetDistance</code> class.</p> <pre><code>from themap.data import ProteinDataset\nfrom themap.distance import ProteinDatasetDistance\n\n# load some datasets\nsource_protein = ProteinDataset.load_from_file(\"datasets/train/train_proteins.fasta\")\ntarget_protein = ProteinDataset.load_from_file(\"datasets/test/test_proteins.fasta\")\n\n# get the features\nprotein_featurizer = \"esm2_t33_650M_UR50D\"\nsource_protein_features = source_protein.get_features(protein_featurizer)\ntarget_protein_features = target_protein.get_features(protein_featurizer)\n\n# calculate the distance\nDist = ProteinDatasetDistance(source_protein, target_protein, \"euclidean\")\nDist.get_distance()\n#{'CHEMBL2219236': {'CHEMBL2219236': 2.9516282297179703,\n#'CHEMBL2219358': 4.372332083302979,\n#'CHEMBL1963831': 4.258244298189887},\n#'CHEMBL2219358': {'CHEMBL2219236': 3.560959265946417,\n#'CHEMBL2219358': 2.005268985065835,\n#'CHEMBL1963831': 2.772209146380105},\n#'CHEMBL1963831': {'CHEMBL2219236': 3.3623606434721895,\n#'CHEMBL2219358': 1.9580669485355773,\n#'CHEMBL1963831': 2.452369399042511}}\n</code></pre>"},{"location":"index.html#tutorials","title":"Tutorials","text":"<p>Check out the tutorials to get started.</p>"},{"location":"api/data.html","title":"<code>themap.data</code>","text":""},{"location":"api/data.html#themap.data","title":"themap.data","text":""},{"location":"api/data.html#themap.data.MetaData","title":"MetaData  <code>dataclass</code>","text":"<p>Data structure holding metadata for a batch of tasks.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>List[str]</code> <p>list of string describing the tasks these metadata are taken from.</p> required <code>protein</code> <code>ProteinDataset</code> <p>ProteinDataset object.</p> required <code>text_desc</code> <code>Optional[str]</code> <p>Optional text description of the task.</p> required"},{"location":"api/data.html#themap.data.MetaData.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate initialization data.</p>"},{"location":"api/data.html#themap.data.MetaData.get_features","title":"get_features","text":"<pre><code>get_features(model: Any) -&gt; np.ndarray\n</code></pre> <p>Get features from the text description using the specified model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>Model to use for feature extraction from text.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Computed features from text description.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint","title":"MoleculeDatapoint  <code>dataclass</code>","text":"<p>Data structure holding information for a single molecule and associated features.</p> <p>This class represents a single molecule datapoint with its associated features and labels. It provides methods to compute molecular fingerprints and features, and includes various molecular properties as properties.</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>str</code> <p>String describing the task this datapoint is taken from.</p> <code>smiles</code> <code>str</code> <p>SMILES string describing the molecule this datapoint corresponds to.</p> <code>bool_label</code> <code>bool</code> <p>bool classification label, usually derived from the numeric label using a threshold.</p> <code>numeric_label</code> <code>Optional[float]</code> <p>numerical label (e.g., activity), usually measured in the lab</p> <code>_fingerprint</code> <code>Optional[ndarray]</code> <p>optional ECFP (Extended-Connectivity Fingerprint) for the molecule.</p> <code>_features</code> <code>Optional[ndarray]</code> <p>optional features for the molecule. features are how we represent the molecule in the model</p> <code>_rdkit_mol</code> <code>Optional[Mol]</code> <p>cached RDKit molecule object</p> Properties <p>number_of_atoms (int): Number of atoms in the molecule number_of_bonds (int): Number of bonds in the molecule molecular_weight (float): Molecular weight in atomic mass units rdkit_mol (Chem.Mol): RDKit molecule object (lazy loaded)</p> <p>Methods:</p> Name Description <code>get_fingerprint</code> <p>Computes and returns the Morgan fingerprint for the molecule</p> <code>get_features</code> <p>Computes and returns molecular features using specified featurizer</p> Example"},{"location":"api/data.html#themap.data.MoleculeDatapoint--create-a-molecule-datapoint","title":"Create a molecule datapoint","text":"<p>datapoint = MoleculeDatapoint( ...     task_id=\"toxicity_prediction\", ...     smiles=\"CCO\",  # ethanol ...     bool_label=True, ...     numeric_label=0.8 ... )</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint--access-molecular-properties","title":"Access molecular properties","text":"<p>print(f\"Number of atoms: {datapoint.number_of_atoms}\") Number of atoms: 3 print(f\"Molecular weight: {datapoint.molecular_weight:.2f}\") Molecular weight: 46.04</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint--get-molecular-features","title":"Get molecular features","text":"<p>fingerprint = datapoint.get_fingerprint() features = datapoint.get_features(featurizer=\"ecfp\")</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.rdkit_mol","title":"rdkit_mol  <code>property</code>","text":"<pre><code>rdkit_mol: Optional[Mol]\n</code></pre> <p>Get the RDKit molecule object.</p> <p>This property lazily initializes the RDKit molecule if it hasn't been created yet. The molecule is cached to avoid recreating it multiple times.</p> <p>Returns:</p> Type Description <code>Optional[Mol]</code> <p>Optional[Chem.Mol]: RDKit molecule object. Returns None if molecule creation fails.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.number_of_atoms","title":"number_of_atoms  <code>property</code>","text":"<pre><code>number_of_atoms: int\n</code></pre> <p>Get the number of heavy atoms in the molecule.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of heavy atoms in the molecule.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.number_of_bonds","title":"number_of_bonds  <code>property</code>","text":"<pre><code>number_of_bonds: int\n</code></pre> <p>Get the number of bonds in the molecule.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of bonds in the molecule.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.molecular_weight","title":"molecular_weight  <code>property</code>","text":"<pre><code>molecular_weight: float\n</code></pre> <p>Get the molecular weight of the molecule.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Molecular weight of the molecule in atomic mass units.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.logp","title":"logp  <code>property</code>","text":"<pre><code>logp: float\n</code></pre> <p>Calculate octanol-water partition coefficient.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>LogP value of the molecule.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.num_rotatable_bonds","title":"num_rotatable_bonds  <code>property</code>","text":"<pre><code>num_rotatable_bonds: int\n</code></pre> <p>Get number of rotatable bonds.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of rotatable bonds in the molecule.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.smiles_canonical","title":"smiles_canonical  <code>property</code>","text":"<pre><code>smiles_canonical: str\n</code></pre> <p>Get canonical SMILES representation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Canonical SMILES string for the molecule.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate initialization data.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert datapoint to dictionary for serialization.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; MoleculeDatapoint\n</code></pre> <p>Create datapoint from dictionary.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.get_fingerprint","title":"get_fingerprint","text":"<pre><code>get_fingerprint(force_recompute: bool = False) -&gt; Optional[np.ndarray]\n</code></pre> <p>Get the Morgan fingerprint for a molecule.</p> <p>This method computes the Extended-Connectivity Fingerprint (ECFP) for the molecule using RDKit's Morgan fingerprint generator. The fingerprint is cached after first computation to avoid recomputing.</p> <p>Parameters:</p> Name Type Description Default <code>force_recompute</code> <code>bool</code> <p>If True, the fingerprint is recomputed even if it has already been computed.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[ndarray]</code> <p>Optional[np.ndarray]: Morgan fingerprint for the molecule (r=2, nbits=2048). The fingerprint is a binary vector representing the molecular structure. Returns None if fingerprint generation fails.</p>"},{"location":"api/data.html#themap.data.MoleculeDatapoint.get_features","title":"get_features","text":"<pre><code>get_features(\n    featurizer_name: Optional[str] = None, force_recompute: bool = False\n) -&gt; Optional[np.ndarray]\n</code></pre> <p>Get features for a molecule using a featurizer model.</p> <p>This method computes molecular features using the specified featurizer model. The features are cached after first computation to avoid recomputing.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>Optional[str]</code> <p>Name of the featurizer model to use. If None, no featurization is performed.</p> <code>None</code> <code>force_recompute</code> <code>bool</code> <p>If True, the features are recomputed even if they have already been computed.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[ndarray]</code> <p>Optional[np.ndarray]: Features for the molecule. The shape and content depend on the featurizer used. Returns None if feature generation fails.</p>"},{"location":"api/data.html#themap.data.MoleculeDataset","title":"MoleculeDataset  <code>dataclass</code>","text":"<p>Data structure holding information for a dataset of molecules.</p> <p>This class represents a collection of molecule datapoints, providing methods for dataset manipulation, feature computation, and statistical analysis.</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>str</code> <p>String describing the task this dataset is taken from.</p> <code>data</code> <code>List[MoleculeDatapoint]</code> <p>List of MoleculeDatapoint objects.</p> <code>_features</code> <code>Optional[FeatureArray]</code> <p>Cached features for the dataset.</p> <code>_cache_info</code> <code>Dict[str, Any]</code> <p>Information about the feature caching.</p>"},{"location":"api/data.html#themap.data.MoleculeDataset.get_features","title":"get_features  <code>property</code>","text":"<pre><code>get_features: Optional[FeatureArray]\n</code></pre> <p>Get the cached features for the dataset.</p> <p>Returns:</p> Type Description <code>Optional[FeatureArray]</code> <p>Optional[FeatureArray]: Cached features for the dataset if available, None otherwise.</p>"},{"location":"api/data.html#themap.data.MoleculeDataset.get_ratio","title":"get_ratio  <code>property</code>","text":"<pre><code>get_ratio: float\n</code></pre> <p>Get the ratio of positive to negative examples in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Ratio of positive to negative examples in the dataset.</p>"},{"location":"api/data.html#themap.data.MoleculeDataset.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate dataset initialization.</p>"},{"location":"api/data.html#themap.data.MoleculeDataset.get_dataset_embedding","title":"get_dataset_embedding","text":"<pre><code>get_dataset_embedding(\n    featurizer_name: str,\n    n_jobs: Optional[int] = None,\n    force_recompute: bool = False,\n    batch_size: int = 1000,\n) -&gt; FeatureArray\n</code></pre> <p>Get the features for the entire dataset using a featurizer.</p> <p>Efficiently computes features for all molecules in the dataset using the  specified featurizer, taking advantage of the featurizer's built-in  parallelization capabilities and maintaining a two-level cache strategy.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>str</code> <p>Name of the featurizer to use</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>Number of parallel jobs. If provided, temporarily                  overrides the featurizer's own setting</p> <code>None</code> <code>force_recompute</code> <code>bool</code> <p>Whether to force recomputation even if cached</p> <code>False</code> <code>batch_size</code> <code>int</code> <p>Batch size for processing, used for memory efficiency             when handling large datasets</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>FeatureArray</code> <code>FeatureArray</code> <p>Features for the entire dataset, shape (n_samples, n_features)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the generated features length doesn't match the dataset length</p>"},{"location":"api/data.html#themap.data.MoleculeDataset.clear_cache","title":"clear_cache","text":"<pre><code>clear_cache()\n</code></pre> <p>Clear all cached features.</p>"},{"location":"api/data.html#themap.data.MoleculeDataset.get_cache_info","title":"get_cache_info","text":"<pre><code>get_cache_info()\n</code></pre> <p>Get information about the current cache state.</p>"},{"location":"api/data.html#themap.data.MoleculeDataset.get_prototype","title":"get_prototype","text":"<pre><code>get_prototype(featurizer_name: str) -&gt; tuple[FeatureArray, FeatureArray]\n</code></pre> <p>Get the prototype of the dataset.</p> <p>This method calculates the mean feature vector of positive and negative examples in the dataset using the specified featurizer.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>str</code> <p>Name of the featurizer to use.</p> required <p>Returns:</p> Type Description <code>tuple[FeatureArray, FeatureArray]</code> <p>tuple[FeatureArray, FeatureArray]: Tuple containing: - positive_prototype: Mean feature vector of positive examples - negative_prototype: Mean feature vector of negative examples</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are no positive or negative examples in the dataset</p>"},{"location":"api/data.html#themap.data.MoleculeDataset.load_from_file","title":"load_from_file  <code>staticmethod</code>","text":"<pre><code>load_from_file(path: Union[str, RichPath]) -&gt; MoleculeDataset\n</code></pre> <p>Load dataset from a JSONL.GZ file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, RichPath]</code> <p>Path to the JSONL.GZ file.</p> required <p>Returns:</p> Name Type Description <code>MoleculeDataset</code> <code>MoleculeDataset</code> <p>Loaded dataset.</p>"},{"location":"api/data.html#themap.data.MoleculeDataset.filter","title":"filter","text":"<pre><code>filter(condition: Callable[[MoleculeDatapoint], bool]) -&gt; MoleculeDataset\n</code></pre> <p>Filter dataset based on a condition.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Callable[[MoleculeDatapoint], bool]</code> <p>Function that returns True/False for each datapoint.</p> required <p>Returns:</p> Name Type Description <code>MoleculeDataset</code> <code>MoleculeDataset</code> <p>New dataset containing only the filtered datapoints.</p>"},{"location":"api/data.html#themap.data.MoleculeDataset.get_statistics","title":"get_statistics","text":"<pre><code>get_statistics() -&gt; DatasetStats\n</code></pre> <p>Get statistics about the dataset.</p> <p>Returns:</p> Name Type Description <code>DatasetStats</code> <code>DatasetStats</code> <p>Dictionary containing: - size: Total number of datapoints - positive_ratio: Ratio of positive to negative examples - avg_molecular_weight: Average molecular weight - avg_atoms: Average number of atoms - avg_bonds: Average number of bonds</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dataset is empty</p>"},{"location":"api/data.html#themap.data.DataFold","title":"DataFold","text":"<p>Enum for data fold types.</p>"},{"location":"api/data.html#themap.data.MoleculeDatasets","title":"MoleculeDatasets","text":"<p>Dataset of related tasks, provided as individual files split into meta-train, meta-valid and meta-test sets.</p>"},{"location":"api/data.html#themap.data.MoleculeDatasets.__init__","title":"__init__","text":"<pre><code>__init__(\n    train_data_paths: List[RichPath] = [],\n    valid_data_paths: List[RichPath] = [],\n    test_data_paths: List[RichPath] = [],\n    num_workers: Optional[int] = None,\n) -&gt; None\n</code></pre> <p>Initialize MoleculeDatasets.</p> <p>Parameters:</p> Name Type Description Default <code>train_data_paths</code> <code>List[RichPath]</code> <p>List of paths to training data files.</p> <code>[]</code> <code>valid_data_paths</code> <code>List[RichPath]</code> <p>List of paths to validation data files.</p> <code>[]</code> <code>test_data_paths</code> <code>List[RichPath]</code> <p>List of paths to test data files.</p> <code>[]</code> <code>num_workers</code> <code>Optional[int]</code> <p>Number of workers for data loading.</p> <code>None</code>"},{"location":"api/data.html#themap.data.MoleculeDatasets.get_num_fold_tasks","title":"get_num_fold_tasks","text":"<pre><code>get_num_fold_tasks(fold: DataFold) -&gt; int\n</code></pre> <p>Get number of tasks in a specific fold.</p> <p>Parameters:</p> Name Type Description Default <code>fold</code> <code>DataFold</code> <p>The fold to get number of tasks for.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of tasks in the fold.</p>"},{"location":"api/data.html#themap.data.MoleculeDatasets.from_directory","title":"from_directory  <code>staticmethod</code>","text":"<pre><code>from_directory(\n    directory: Union[str, RichPath],\n    task_list_file: Optional[Union[str, RichPath]] = None,\n    **kwargs\n) -&gt; MoleculeDatasets\n</code></pre> <p>Create MoleculeDatasets from a directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Union[str, RichPath]</code> <p>Directory containing train/valid/test subdirectories.</p> required <code>task_list_file</code> <code>Optional[Union[str, RichPath]]</code> <p>File containing list of tasks to include.</p> <code>None</code> <code>**kwargs</code> <code>any</code> <p>Additional arguments to pass to MoleculeDatasets constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>MoleculeDatasets</code> <code>MoleculeDatasets</code> <p>Created dataset.</p>"},{"location":"api/data.html#themap.data.MoleculeDatasets.get_task_names","title":"get_task_names","text":"<pre><code>get_task_names(data_fold: DataFold) -&gt; List[str]\n</code></pre> <p>Get list of task names in a specific fold.</p> <p>Parameters:</p> Name Type Description Default <code>data_fold</code> <code>DataFold</code> <p>The fold to get task names for.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of task names in the fold.</p>"},{"location":"api/data.html#themap.data.ProteinDataset","title":"ProteinDataset  <code>dataclass</code>","text":"<p>Data structure holding information for proteins (list of protein).</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>List[str]</code> <p>list of string describing the tasks these protein are taken from.</p> required <code>protein</code> <code>ProteinDict</code> <p>dictionary mapping the protein id to the protein sequence.</p> required <code>features</code> <code>Optional[FeatureArray]</code> <p>Optional pre-computed protein features.</p> <code>None</code>"},{"location":"api/data.html#themap.data.ProteinDataset.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate initialization data.</p>"},{"location":"api/data.html#themap.data.ProteinDataset.get_features","title":"get_features","text":"<pre><code>get_features(model: ModelType) -&gt; FeatureArray\n</code></pre> <p>Get protein features using the specified model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ModelType</code> <p>Model to use for feature extraction.</p> required <p>Returns:</p> Name Type Description <code>FeatureArray</code> <code>FeatureArray</code> <p>Computed protein features.</p>"},{"location":"api/data.html#themap.data.ProteinDataset.load_from_file","title":"load_from_file  <code>staticmethod</code>","text":"<pre><code>load_from_file(path: Union[str, RichPath]) -&gt; ProteinDataset\n</code></pre> <p>Load protein dataset from a FASTA file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, RichPath]</code> <p>Path to the FASTA file.</p> required <p>Returns:</p> Name Type Description <code>ProteinDataset</code> <code>ProteinDataset</code> <p>Loaded protein dataset.</p>"},{"location":"api/data.html#themap.data.Task","title":"Task  <code>dataclass</code>","text":"<p>A task represents a molecular property prediction problem.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>Unique identifier for the task</p> required <code>data</code> <code>MoleculeDataset</code> <p>Dataset containing molecular data</p> required <code>metadata</code> <code>MetaData</code> <p>Metadata about the task</p> required <code>hardness</code> <code>Optional[float]</code> <p>Optional measure of task difficulty</p> <code>None</code>"},{"location":"api/data.html#themap.data.Task.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> <p>Validate task initialization.</p>"},{"location":"api/data.html#themap.data.Task.get_task_embedding","title":"get_task_embedding","text":"<pre><code>get_task_embedding(data_model: Any, metadata_model: Any) -&gt; np.ndarray\n</code></pre> <p>Get combined embedding of data and metadata features.</p> <p>Parameters:</p> Name Type Description Default <code>data_model</code> <code>Any</code> <p>Model to use for data feature extraction</p> required <code>metadata_model</code> <code>Any</code> <p>Model to use for metadata feature extraction</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Combined feature vector</p>"},{"location":"api/data.html#themap.data.TorchMoleculeDataset","title":"TorchMoleculeDataset","text":"<p>               Bases: <code>Dataset</code></p> <p>PYTORCH Dataset for molecular data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>MoleculeDataset</code> <p>MoleculeDataset object</p> required <code>transform</code> <code>callable</code> <p>transform to apply to data</p> <code>None</code> <code>target_transform</code> <code>callable</code> <p>transform to apply to targets</p> <code>None</code>"},{"location":"api/data.html#themap.data.TorchMoleculeDataset.__init__","title":"__init__","text":"<pre><code>__init__(data: MoleculeDataset, transform=None, target_transform=None)\n</code></pre> <p>Initialize TorchMoleculeDataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>MoleculeDataset</code> <p>Input dataset</p> required <code>transform</code> <code>callable</code> <p>Transform to apply to data</p> <code>None</code> <code>target_transform</code> <code>callable</code> <p>Transform to apply to targets</p> <code>None</code>"},{"location":"api/data.html#themap.data.TorchMoleculeDataset.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; tuple[torch.Tensor, torch.Tensor]\n</code></pre> <p>Get a data sample.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the sample to get</p> required <p>Returns:</p> Type Description <code>tuple[Tensor, Tensor]</code> <p>tuple[torch.Tensor, torch.Tensor]: Tuple of (features, label)</p>"},{"location":"api/data.html#themap.data.TorchMoleculeDataset.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Get the number of samples in the dataset.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of samples</p>"},{"location":"api/data.html#themap.data.TorchMoleculeDataset.create_dataloader","title":"create_dataloader  <code>classmethod</code>","text":"<pre><code>create_dataloader(\n    data: MoleculeDataset, batch_size: int = 64, shuffle: bool = True, **kwargs\n) -&gt; torch.utils.data.DataLoader\n</code></pre> <p>Create PyTorch DataLoader.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>MoleculeDataset</code> <p>Input dataset</p> required <code>batch_size</code> <code>int</code> <p>Batch size</p> <code>64</code> <code>shuffle</code> <code>bool</code> <p>Whether to shuffle data</p> <code>True</code> <code>**kwargs</code> <code>any</code> <p>Additional arguments for DataLoader</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>DataLoader</code> <code>DataLoader</code> <p>PyTorch data loader</p>"},{"location":"api/data.html#themap.data.MoleculeDataloader","title":"MoleculeDataloader","text":"<pre><code>MoleculeDataloader(\n    data: MoleculeDataset,\n    batch_size: int = 64,\n    shuffle: bool = True,\n    transform=None,\n    target_transform=None,\n) -&gt; torch.utils.data.DataLoader\n</code></pre> <p>Load molecular data and create PYTORCH dataloader.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>MoleculeDataset</code> <p>MoleculeDataset object</p> required <code>batch_size</code> <code>int</code> <p>batch size</p> <code>64</code> <code>shuffle</code> <code>bool</code> <p>whether to shuffle data</p> <code>True</code> <code>transform</code> <code>callable</code> <p>transform to apply to data</p> <code>None</code> <code>target_transform</code> <code>callable</code> <p>transform to apply to targets</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dataset_loader</code> <code>DataLoader</code> <p>PYTORCH dataloader</p>"},{"location":"tutorials/Basics.html","title":"Importing Required Libraries","text":"In\u00a0[1]: Copied! <pre>#import general packages\nimport os\nimport argparse\nimport logging\nimport sys\nfrom typing import Dict, List\nfrom dpu_utils.utils.richpath import RichPath\nimport pickle\n\nimport torch\nfrom tqdm.notebook import tqdm\nimport pandas as pd\n\n# Setting up local details:\n# This should be the location of the checkout of the THEMAP repository:\nrepo_path = os.path.dirname(os.path.abspath(\"\"))\nCHECKOUT_PATH = repo_path\nDATASET_PATH = os.path.join(repo_path, \"datasets\")\n\nos.chdir(CHECKOUT_PATH)\nsys.path.insert(0, CHECKOUT_PATH)\n</pre> #import general packages import os import argparse import logging import sys from typing import Dict, List from dpu_utils.utils.richpath import RichPath import pickle  import torch from tqdm.notebook import tqdm import pandas as pd  # Setting up local details: # This should be the location of the checkout of the THEMAP repository: repo_path = os.path.dirname(os.path.abspath(\"\")) CHECKOUT_PATH = repo_path DATASET_PATH = os.path.join(repo_path, \"datasets\")  os.chdir(CHECKOUT_PATH) sys.path.insert(0, CHECKOUT_PATH) In\u00a0[2]: Copied! <pre>from third_party.otdd.otdd.pytorch.datasets import MolDataset, load_molecule_data\nfrom third_party.otdd.otdd.pytorch.distance import DatasetDistance\n</pre> from third_party.otdd.otdd.pytorch.datasets import MolDataset, load_molecule_data from third_party.otdd.otdd.pytorch.distance import DatasetDistance <pre>ot.gpu not found - coupling computation will be in cpu\n</pre> In\u00a0[3]: Copied! <pre># import visualization packages\n%matplotlib inline\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nimport seaborn as sns\nfrom sklearn.manifold import TSNE\nimport pandas as pd\nfrom themap.utils import compute_task_hardness_from_distance_matrix, normalize, internal_hardness, otdd_hardness\nfrom themap.data import MoleculeDatapoint, MoleculeDataset, ProteinDataset\n\n\nlight_color = plt.get_cmap(\"plasma\").colors[170]\ndark_color = \"black\"\n\nmatplotlib.rcParams.update(\n    {\n        \"pgf.texsystem\": \"pdflatex\",\n        \"font.family\": \"serif\",\n        \"font.serif\": \"Computer Modern Roman\",\n        \"font.size\": 20,\n        \"text.usetex\": True,\n        \"pgf.rcfonts\": False,\n    }\n)\n</pre> # import visualization packages %matplotlib inline  import matplotlib import matplotlib.pyplot as plt import ipywidgets as widgets import seaborn as sns from sklearn.manifold import TSNE import pandas as pd from themap.utils import compute_task_hardness_from_distance_matrix, normalize, internal_hardness, otdd_hardness from themap.data import MoleculeDatapoint, MoleculeDataset, ProteinDataset   light_color = plt.get_cmap(\"plasma\").colors[170] dark_color = \"black\"  matplotlib.rcParams.update(     {         \"pgf.texsystem\": \"pdflatex\",         \"font.family\": \"serif\",         \"font.serif\": \"Computer Modern Roman\",         \"font.size\": 20,         \"text.usetex\": True,         \"pgf.rcfonts\": False,     } ) In\u00a0[4]: Copied! <pre>source_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"train\", \"CHEMBL1023359.jsonl.gz\"))\ntarget_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"test\", \"CHEMBL2219358.jsonl.gz\"))\n\nsource_dataset = MoleculeDataset.load_from_file(source_dataset_path)\ntarget_dataset = MoleculeDataset.load_from_file(target_dataset_path)\n</pre> source_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"train\", \"CHEMBL1023359.jsonl.gz\")) target_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"test\", \"CHEMBL2219358.jsonl.gz\"))  source_dataset = MoleculeDataset.load_from_file(source_dataset_path) target_dataset = MoleculeDataset.load_from_file(target_dataset_path) In\u00a0[5]: Copied! <pre>Molecule_Feaurizer = widgets.Dropdown(\n    options=['gin_supervised_infomax', 'gin_supervised_masking', 'gin_supervised_edgepred'],\n    value='gin_supervised_infomax',\n    description='Molecule Featurizer:',\n    disabled=False,\n)\n</pre> Molecule_Feaurizer = widgets.Dropdown(     options=['gin_supervised_infomax', 'gin_supervised_masking', 'gin_supervised_edgepred'],     value='gin_supervised_infomax',     description='Molecule Featurizer:',     disabled=False, ) In\u00a0[6]: Copied! <pre>Molecule_Feaurizer\n</pre> Molecule_Feaurizer Out[6]: <pre>Dropdown(description='Molecule Featurizer:', options=('gin_supervised_infomax', 'gin_supervised_masking', 'gin\u2026</pre> In\u00a0[7]: Copied! <pre>## compute and load the embeddings\nmolecule_feaurizer = Molecule_Feaurizer.value\nsource_features = source_dataset.get_dataset_embedding(molecule_feaurizer)\ntarget_features = target_dataset.get_dataset_embedding(molecule_feaurizer)\nassert source_features.shape[1] == target_features.shape[1]\n</pre> ## compute and load the embeddings molecule_feaurizer = Molecule_Feaurizer.value source_features = source_dataset.get_dataset_embedding(molecule_feaurizer) target_features = target_dataset.get_dataset_embedding(molecule_feaurizer) assert source_features.shape[1] == target_features.shape[1] In\u00a0[8]: Copied! <pre>source_dataset_otdd = MolDataset(source_dataset)\ntarget_dataset_otdd = MolDataset(target_dataset)\n</pre> source_dataset_otdd = MolDataset(source_dataset) target_dataset_otdd = MolDataset(target_dataset) In\u00a0[9]: Copied! <pre>source_dataset_loader = load_molecule_data(source_dataset)\ntarget_dataset_loader = load_molecule_data(target_dataset)\n</pre> source_dataset_loader = load_molecule_data(source_dataset) target_dataset_loader = load_molecule_data(target_dataset) In\u00a0[\u00a0]: Copied! <pre># Instantiate distance\ndist = DatasetDistance(source_dataset_loader, target_dataset_loader,\n                       inner_ot_method = 'exact',\n                       debiased_loss = True,\n                       p = 2, entreg = 1e-1,\n                       device='cuda' if torch.cuda.is_available() else 'cpu')\n\nd = dist.distance(maxsamples = 1000)\nprint(f'OTDD(src,tgt)={d}')\n</pre> # Instantiate distance dist = DatasetDistance(source_dataset_loader, target_dataset_loader,                        inner_ot_method = 'exact',                        debiased_loss = True,                        p = 2, entreg = 1e-1,                        device='cuda' if torch.cuda.is_available() else 'cpu')  d = dist.distance(maxsamples = 1000) print(f'OTDD(src,tgt)={d}') In\u00a0[\u00a0]: Copied! <pre>import glob\nsource_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"train\", \"CHEMBL*\"))\ntarget_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"test\", \"CHEMBL*\"))\nchem_distances = {}\nfor target_path in tqdm(target_datasets_path):\n    chem_distance = {}\n    target_dataset_path = RichPath.create(target_path)\n    target_dataset = MoleculeDataset.load_from_file(target_dataset_path)\n    target_features = target_dataset.get_dataset_embedding(molecule_feaurizer)\n    target_dataset_otdd = MolDataset(target_dataset)\n    target_dataset_loader = load_molecule_data(target_dataset)\n    for source_path in source_datasets_path:\n        source_dataset_path = RichPath.create(source_path)\n        source_dataset = MoleculeDataset.load_from_file(source_dataset_path)\n        source_features = source_dataset.get_dataset_embedding(molecule_feaurizer)\n        source_dataset_otdd = MolDataset(source_dataset)\n        source_dataset_loader = load_molecule_data(source_dataset)\n\n        dist = DatasetDistance(source_dataset_loader, target_dataset_loader,\n                               inner_ot_method = 'exact',\n                               debiased_loss = True,\n                               p = 2, entreg = 1e-1,\n                               device='cuda' if torch.cuda.is_available() else 'cpu')\n        \n        d = dist.distance(maxsamples = 1000)\n        print(f'OTDD({source_dataset.task_id},{target_dataset.task_id})= {d}')\n        chem_distance[source_dataset.task_id] = d.cpu().item()\n    chem_distances[target_dataset.task_id] = chem_distance\n</pre> import glob source_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"train\", \"CHEMBL*\")) target_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"test\", \"CHEMBL*\")) chem_distances = {} for target_path in tqdm(target_datasets_path):     chem_distance = {}     target_dataset_path = RichPath.create(target_path)     target_dataset = MoleculeDataset.load_from_file(target_dataset_path)     target_features = target_dataset.get_dataset_embedding(molecule_feaurizer)     target_dataset_otdd = MolDataset(target_dataset)     target_dataset_loader = load_molecule_data(target_dataset)     for source_path in source_datasets_path:         source_dataset_path = RichPath.create(source_path)         source_dataset = MoleculeDataset.load_from_file(source_dataset_path)         source_features = source_dataset.get_dataset_embedding(molecule_feaurizer)         source_dataset_otdd = MolDataset(source_dataset)         source_dataset_loader = load_molecule_data(source_dataset)          dist = DatasetDistance(source_dataset_loader, target_dataset_loader,                                inner_ot_method = 'exact',                                debiased_loss = True,                                p = 2, entreg = 1e-1,                                device='cuda' if torch.cuda.is_available() else 'cpu')                  d = dist.distance(maxsamples = 1000)         print(f'OTDD({source_dataset.task_id},{target_dataset.task_id})= {d}')         chem_distance[source_dataset.task_id] = d.cpu().item()     chem_distances[target_dataset.task_id] = chem_distance  In\u00a0[12]: Copied! <pre>## Choose your target from chem_distances.keys()\nyour_tasks = \"CHEMBL2219236\"\nchem_dist = chem_distances[your_tasks]\nfig = plt.figure(figsize=(12, 5))\nplt.bar(chem_dist.keys(), chem_dist.values())\nplt.xlabel('Source datasets')\nplt.ylabel('OTDD')\nplt.title(f'OTDD between source datasets and target {your_tasks}')\nplt.xticks(rotation=90)\nplt.grid(axis='y', linestyle='--', alpha=1.0)\nplt.show()\n</pre> ## Choose your target from chem_distances.keys() your_tasks = \"CHEMBL2219236\" chem_dist = chem_distances[your_tasks] fig = plt.figure(figsize=(12, 5)) plt.bar(chem_dist.keys(), chem_dist.values()) plt.xlabel('Source datasets') plt.ylabel('OTDD') plt.title(f'OTDD between source datasets and target {your_tasks}') plt.xticks(rotation=90) plt.grid(axis='y', linestyle='--', alpha=1.0) plt.show() In\u00a0[15]: Copied! <pre>chem_distances.keys()\n</pre> chem_distances.keys() Out[15]: <pre>dict_keys(['CHEMBL2219236', 'CHEMBL1963831', 'CHEMBL2219358'])</pre> In\u00a0[13]: Copied! <pre>Protein_Feaurizer = widgets.Dropdown(\n    options=['esm2_t6_8M_UR50D', 'esm2_t12_35M_UR50D', 'esm2_t30_150M_UR50D', 'esm2_t33_650M_UR50D', 'esm2_t36_3B_UR50D'],\n    value='esm2_t33_650M_UR50D',\n    description='Protein Featurizer:',\n    disabled=False,\n)\n</pre> Protein_Feaurizer = widgets.Dropdown(     options=['esm2_t6_8M_UR50D', 'esm2_t12_35M_UR50D', 'esm2_t30_150M_UR50D', 'esm2_t33_650M_UR50D', 'esm2_t36_3B_UR50D'],     value='esm2_t33_650M_UR50D',     description='Protein Featurizer:',     disabled=False, ) In\u00a0[14]: Copied! <pre>Protein_Feaurizer\n</pre> Protein_Feaurizer Out[14]: <pre>Dropdown(description='Protein Featurizer:', index=3, options=('esm2_t6_8M_UR50D', 'esm2_t12_35M_UR50D', 'esm2_\u2026</pre> In\u00a0[15]: Copied! <pre>source_protein = ProteinDataset.load_from_file(\"datasets/train/train_proteins.fasta\")\ntarget_protein = ProteinDataset.load_from_file(\"datasets/test/test_proteins.fasta\")\n</pre> source_protein = ProteinDataset.load_from_file(\"datasets/train/train_proteins.fasta\") target_protein = ProteinDataset.load_from_file(\"datasets/test/test_proteins.fasta\") In\u00a0[16]: Copied! <pre>protein_featurizer = Protein_Feaurizer.value\nsource_protein_features = source_protein.get_features(protein_featurizer)\ntarget_protein_features = target_protein.get_features(protein_featurizer)\n</pre> protein_featurizer = Protein_Feaurizer.value source_protein_features = source_protein.get_features(protein_featurizer) target_protein_features = target_protein.get_features(protein_featurizer) In\u00a0[17]: Copied! <pre>from scipy.spatial.distance import cdist\ndist = cdist(source_protein.features, target_protein.features)\n</pre> from scipy.spatial.distance import cdist dist = cdist(source_protein.features, target_protein.features) In\u00a0[18]: Copied! <pre>prot_distances = {}\nfor i, target_prot in enumerate(target_protein.task_id):\n    prot_distance = {}\n    for j, source_prot in enumerate(source_protein.task_id):\n        prot_distance[source_prot] = dist[j, i]\n    prot_distances[target_prot] = prot_distance\n</pre> prot_distances = {} for i, target_prot in enumerate(target_protein.task_id):     prot_distance = {}     for j, source_prot in enumerate(source_protein.task_id):         prot_distance[source_prot] = dist[j, i]     prot_distances[target_prot] = prot_distance In\u00a0[24]: Copied! <pre>## Choose your target from chem_distances.keys()\nyour_tasks = \"CHEMBL2219236\"\nprot_dist = prot_distances[your_tasks]\nfig = plt.figure(figsize=(12, 5))\nplt.bar(prot_dist.keys(), prot_dist.values())\nplt.xlabel('Source datasets')\nplt.ylabel('Protein Distance')\nplt.title(f'Protein Distance between source datasets and target {your_tasks}')\nplt.xticks(rotation=90)\nplt.grid(axis='y', linestyle='--', alpha=1.0)\nplt.show()\n</pre> ## Choose your target from chem_distances.keys() your_tasks = \"CHEMBL2219236\" prot_dist = prot_distances[your_tasks] fig = plt.figure(figsize=(12, 5)) plt.bar(prot_dist.keys(), prot_dist.values()) plt.xlabel('Source datasets') plt.ylabel('Protein Distance') plt.title(f'Protein Distance between source datasets and target {your_tasks}') plt.xticks(rotation=90) plt.grid(axis='y', linestyle='--', alpha=1.0) plt.show() <p>Now, we can answer to the following questions:</p> <ul> <li>Given a target task, what is the closest source task in terms of chemical and protein distances?</li> <li>Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space?</li> <li>Given a target task and source tasks, how to pick the k nearset source tasks fo transfer learning?</li> </ul> <p>So, let's answer to this questions in the following sections.</p> In\u00a0[42]: Copied! <pre>chem_df = pd.DataFrame.from_dict(chem_distances)\nprot_df = pd.DataFrame.from_dict(prot_distances)\n</pre> chem_df = pd.DataFrame.from_dict(chem_distances) prot_df = pd.DataFrame.from_dict(prot_distances) In\u00a0[69]: Copied! <pre>## Given a target task, what is the closest source task in terms of chemical and protein distances?\nyour_task = \"CHEMBL2219236\"\n\nchem_distance = chem_df[your_task]\nprot_distance = prot_df[your_task]\n\nnormalized_chem_distance=(chem_distance-chem_distance.min())/(chem_distance.max()-chem_distance.min())\nnormalized_prot_distance=(prot_distance-prot_distance.min())/(prot_distance.max()-prot_distance.min())\nnormalized_prot_distance = normalized_prot_distance.reindex(normalized_chem_distance.index)\nnormalized_comb_distance = (normalized_chem_distance + normalized_prot_distance)/2\n\n\nprint(f'Closest source task in terms of chemical distance: {chem_distance.idxmin()}')\nprint(f'Closest source task in terms of protein distance: {prot_distance.idxmin()}')\nprint(f'Closest source task in terms of combination of chemical and protein distance: {normalized_comb_distance.idxmin()}')\n</pre> ## Given a target task, what is the closest source task in terms of chemical and protein distances? your_task = \"CHEMBL2219236\"  chem_distance = chem_df[your_task] prot_distance = prot_df[your_task]  normalized_chem_distance=(chem_distance-chem_distance.min())/(chem_distance.max()-chem_distance.min()) normalized_prot_distance=(prot_distance-prot_distance.min())/(prot_distance.max()-prot_distance.min()) normalized_prot_distance = normalized_prot_distance.reindex(normalized_chem_distance.index) normalized_comb_distance = (normalized_chem_distance + normalized_prot_distance)/2   print(f'Closest source task in terms of chemical distance: {chem_distance.idxmin()}') print(f'Closest source task in terms of protein distance: {prot_distance.idxmin()}') print(f'Closest source task in terms of combination of chemical and protein distance: {normalized_comb_distance.idxmin()}') <pre>Closest source task in terms of chemical distance: CHEMBL2218944\nClosest source task in terms of protein distance: CHEMBL2219012\nClosest source task in terms of combination of chemical and protein distance: CHEMBL2219012\n</pre> In\u00a0[91]: Copied! <pre>## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space?\n## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks.\nk = 3\n\ntarget_tasks = chem_df.columns\nsource_tasks = chem_df.index\n\nhardness_all={}\nfor target_task in target_tasks:\n    hardness={}\n    chem_distance = chem_df[target_task]\n    prot_distance = prot_df[target_task]\n\n    chem_distance=chem_distance.sort_values()\n    prot_distance = prot_distance.sort_values()\n\n    hardness['EXT_CHEM'] = chem_distance[:k].sum()/k\n    hardness['EXT_PROT'] = prot_distance[:k].sum()/k\n\n    hardness_all[target_task] = hardness\n\nhardness_df = pd.DataFrame.from_dict(hardness_all).T\nhardness_df['all'] = (hardness_df['EXT_CHEM'] + hardness_df['EXT_PROT'])/2\n\nprint(f'Easiest target task in terms of chemical distance: {hardness_df[\"EXT_CHEM\"].idxmin()}')\nprint(f'Easiest target task in terms of protein distance: {hardness_df[\"EXT_PROT\"].idxmin()}')\nprint(f'Easiest target task in terms of combination of chemical and protein distance: {hardness_df[\"all\"].idxmin()}')\n</pre> ## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space? ## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks. k = 3  target_tasks = chem_df.columns source_tasks = chem_df.index  hardness_all={} for target_task in target_tasks:     hardness={}     chem_distance = chem_df[target_task]     prot_distance = prot_df[target_task]      chem_distance=chem_distance.sort_values()     prot_distance = prot_distance.sort_values()      hardness['EXT_CHEM'] = chem_distance[:k].sum()/k     hardness['EXT_PROT'] = prot_distance[:k].sum()/k      hardness_all[target_task] = hardness  hardness_df = pd.DataFrame.from_dict(hardness_all).T hardness_df['all'] = (hardness_df['EXT_CHEM'] + hardness_df['EXT_PROT'])/2  print(f'Easiest target task in terms of chemical distance: {hardness_df[\"EXT_CHEM\"].idxmin()}') print(f'Easiest target task in terms of protein distance: {hardness_df[\"EXT_PROT\"].idxmin()}') print(f'Easiest target task in terms of combination of chemical and protein distance: {hardness_df[\"all\"].idxmin()}') <pre>Easiest target task in terms of chemical distance: CHEMBL2219236\nEasiest target task in terms of protein distance: CHEMBL2219358\nEasiest target task in terms of combination of chemical and protein distance: CHEMBL2219358\n</pre> In\u00a0[93]: Copied! <pre>plt.figure(figsize=(12, 5))\nplt.bar(hardness_df.index, hardness_df['all'])\nplt.xlabel('Target datasets')\nplt.ylabel('Hardness')\nplt.title(f'Hardness of target datasets')\nplt.xticks(rotation=90)\nplt.grid(axis='y', linestyle='--', alpha=1.0)\nplt.show()\n</pre> plt.figure(figsize=(12, 5)) plt.bar(hardness_df.index, hardness_df['all']) plt.xlabel('Target datasets') plt.ylabel('Hardness') plt.title(f'Hardness of target datasets') plt.xticks(rotation=90) plt.grid(axis='y', linestyle='--', alpha=1.0) plt.show() In\u00a0[103]: Copied! <pre>## Given a target task and source tasks, how to pick the k nearset source tasks fo transfer learning?\n## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space?\n## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks.\nk = 3\n\ntarget_tasks = chem_df.columns\nsource_tasks = chem_df.index\n\nclosest_tasks={}\nfor target_task in target_tasks:\n    closest={}\n    chem_distance = chem_df[target_task]\n    prot_distance = prot_df[target_task]\n\n    chem_distance=chem_distance.sort_values()\n    prot_distance = prot_distance.sort_values()\n\n    closest['EXT_CHEM'] = chem_distance[:k].index.to_list()\n    closest['EXT_PROT'] = prot_distance[:k].index.to_list()\n\n    closest_tasks[target_task] = closest\n\nclosest_df = pd.DataFrame.from_dict(closest_tasks).T\n</pre> ## Given a target task and source tasks, how to pick the k nearset source tasks fo transfer learning? ## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space? ## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks. k = 3  target_tasks = chem_df.columns source_tasks = chem_df.index  closest_tasks={} for target_task in target_tasks:     closest={}     chem_distance = chem_df[target_task]     prot_distance = prot_df[target_task]      chem_distance=chem_distance.sort_values()     prot_distance = prot_distance.sort_values()      closest['EXT_CHEM'] = chem_distance[:k].index.to_list()     closest['EXT_PROT'] = prot_distance[:k].index.to_list()      closest_tasks[target_task] = closest  closest_df = pd.DataFrame.from_dict(closest_tasks).T"},{"location":"tutorials/Basics.html#importing-required-libraries","title":"Importing Required Libraries\u00b6","text":"<p>First, we are importing the libraries and modules that are required for running this notebook.</p>"},{"location":"tutorials/Basics.html#create-source-and-target-datasets-data","title":"Create source and target datasets (Data)\u00b6","text":""},{"location":"tutorials/Basics.html#calculate-chemcial-distance-between-target-datasets-with-all-the-source-datasets","title":"Calculate chemcial distance between target datasets with all the source datasets\u00b6","text":""},{"location":"tutorials/Basics.html#calculate-protein-distance-between-target-datasets-with-all-the-source-datasets","title":"Calculate protein distance between target datasets with all the source datasets\u00b6","text":""},{"location":"tutorials/Basics.html#combine-two-distances","title":"Combine Two Distances\u00b6","text":""}]}