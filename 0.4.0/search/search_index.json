{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"THEMAP: Task Hardness Estimation for Molecular Activity Prediction","text":"<p>THEMAP is a comprehensive Python library designed to aid drug discovery by providing powerful methods for estimating task hardness and computing transferability maps for bioactivity prediction tasks. It enables researchers and chemists to efficiently determine the similarity between molecular datasets and make informed decisions about transfer learning strategies.</p> <ul> <li> <p> Quick Start</p> <p>Get up and running with THEMAP in minutes</p> <p> Getting started</p> </li> <li> <p> Tutorials</p> <p>Step-by-step guides for common workflows</p> <p> View tutorials</p> </li> <li> <p> API Reference</p> <p>Detailed documentation for all modules</p> <p> API docs</p> </li> <li> <p> Examples</p> <p>Ready-to-use code examples and scripts</p> <p> Browse examples</p> </li> </ul>"},{"location":"index.html#key-features","title":"Key Features","text":""},{"location":"index.html#multi-modal-distance-computation","title":"\ud83e\uddea Multi-Modal Distance Computation","text":"<ul> <li>Molecular datasets: OTDD, Euclidean, and Cosine distances</li> <li>Protein sequences: ESM2-based embeddings and similarity metrics</li> <li>Metadata integration: Assay descriptions and experimental conditions</li> <li>Combined analysis: Multi-modal fusion strategies</li> </ul>"},{"location":"index.html#task-hardness-estimation","title":"\ud83c\udfaf Task Hardness Estimation","text":"<ul> <li>Transfer learning guidance: Identify similar tasks for knowledge transfer</li> <li>Difficulty quantification: Estimate prediction task complexity</li> <li>Resource optimization: Prioritize computational resources effectively</li> </ul>"},{"location":"index.html#production-ready-framework","title":"\u26a1 Production-Ready Framework","text":"<ul> <li>Scalable architecture: Handle large-scale dataset comparisons</li> <li>Caching system: Efficient feature storage and reuse</li> <li>Error handling: Robust validation and error recovery</li> <li>GPU acceleration: CUDA support for intensive computations</li> </ul>"},{"location":"index.html#unified-task-system","title":"\ud83d\udd2c Unified Task System","text":"<ul> <li>Integrated data management: Molecules, proteins, and metadata in one framework</li> <li>Flexible organization: Train/validation/test fold management</li> <li>Feature extraction: Unified API for multi-modal featurization</li> </ul>"},{"location":"index.html#installation","title":"Installation","text":"Basic InstallationWith All FeaturesDevelopment Setup <pre><code># Clone repository\ngit clone https://github.com/HFooladi/THEMAP.git\ncd THEMAP\n\n# Create conda environment\nconda env create -f environment.yml\nconda activate themap\n\n# Install THEMAP\npip install --no-deps -e .\n</code></pre> <pre><code># Install with all optional dependencies\npip install -e \".[all]\"\n</code></pre> <pre><code># Install development dependencies\npip install -e \".[dev,test]\"\n\n# Run tests\npython run_tests.py\n</code></pre>"},{"location":"index.html#quick-examples","title":"Quick Examples","text":""},{"location":"index.html#molecular-dataset-distance","title":"Molecular Dataset Distance","text":"<p>Compute distances between molecular datasets to understand chemical space similarity:</p> <pre><code>from themap.data.tasks import Tasks\nfrom themap.distance import MoleculeDatasetDistance\n\n# Load tasks from directory structure\ntasks = Tasks.from_directory(\n    directory=\"datasets/\",\n    task_list_file=\"datasets/sample_tasks_list.json\",\n    load_molecules=True,\n    load_proteins=True\n)\n\n# Compute molecular distances using OTDD\nmol_distance = MoleculeDatasetDistance(\n    tasks=tasks,\n    molecule_method=\"otdd\"\n)\n\ndistances = mol_distance.get_distance()\nprint(distances)\n# {'CHEMBL2219358': {'CHEMBL1023359': 7.074}}\n</code></pre>"},{"location":"index.html#unified-multi-modal-analysis","title":"Unified Multi-Modal Analysis","text":"<p>Combine molecular, protein, and metadata information for comprehensive task comparison:</p> <pre><code>from themap.distance import TaskDistance\n\n# Compute combined distances from multiple modalities\ntask_distance = TaskDistance(\n    tasks=tasks,\n    molecule_method=\"cosine\",\n    protein_method=\"euclidean\"\n)\n\n# Get all distance types\nall_distances = task_distance.compute_all_distances(\n    combination_strategy=\"weighted_average\",\n    molecule_weight=0.7,\n    protein_weight=0.3\n)\n\nprint(f\"Molecule distances: {len(all_distances['molecule'])} tasks\")\nprint(f\"Protein distances: {len(all_distances['protein'])} tasks\")\nprint(f\"Combined distances: {len(all_distances['combined'])} tasks\")\n</code></pre>"},{"location":"index.html#protein-similarity-analysis","title":"Protein Similarity Analysis","text":"<p>Analyze protein similarity using advanced sequence embeddings:</p> <pre><code>from themap.distance import ProteinDatasetDistance\n\n# Compute protein distances using ESM2 embeddings\nprot_distance = ProteinDatasetDistance(\n    tasks=tasks,\n    protein_method=\"euclidean\"\n)\n\ndistances = prot_distance.get_distance()\n# Organized as {target_task: {source_task: distance, ...}, ...}\n</code></pre>"},{"location":"index.html#use-cases","title":"Use Cases","text":""},{"location":"index.html#drug-discovery-workflows","title":"Drug Discovery Workflows","text":"<ul> <li>Target identification: Find similar protein targets for drug repurposing</li> <li>Chemical space analysis: Understand molecular diversity across datasets</li> <li>Assay development: Identify related bioactivity assays</li> </ul>"},{"location":"index.html#transfer-learning-applications","title":"Transfer Learning Applications","text":"<ul> <li>Source task selection: Choose optimal training data for new targets</li> <li>Model adaptation: Quantify domain shift between datasets</li> <li>Performance prediction: Estimate model performance on new tasks</li> </ul>"},{"location":"index.html#computational-biology","title":"Computational Biology","text":"<ul> <li>Protein function prediction: Leverage sequence similarity for annotation</li> <li>Chemical-protein interaction: Model molecular-target relationships</li> <li>Multi-omics integration: Combine molecular and protein data</li> </ul>"},{"location":"index.html#performance","title":"Performance","text":"<p>THEMAP is optimized for both accuracy and computational efficiency:</p> Method Speed Memory Accuracy Best For OTDD Slower High Highest Small-medium datasets Euclidean Fast Low Good Large datasets Cosine Fast Low Good High-dimensional features"},{"location":"index.html#scalability-features","title":"Scalability Features","text":"<ul> <li>Parallel processing: Multi-core distance computations</li> <li>Memory management: Efficient handling of large datasets</li> <li>Caching system: Reuse expensive feature computations</li> <li>Batch processing: Handle thousands of dataset comparisons</li> </ul>"},{"location":"index.html#citation","title":"Citation","text":"<p>If you use THEMAP in your research, please cite:</p> <pre><code>@article{fooladi2024quantifying,\n  title={Quantifying the hardness of bioactivity prediction tasks for transfer learning},\n  author={Fooladi, Hosein and Hirte, Steffen and Kirchmair, Johannes},\n  journal={Journal of Chemical Information and Modeling},\n  volume={64},\n  number={10},\n  pages={4031-4046},\n  year={2024},\n  publisher={ACS Publications}\n}\n</code></pre>"},{"location":"index.html#community-and-support","title":"Community and Support","text":""},{"location":"index.html#get-help","title":"Get Help","text":"<ul> <li>Documentation: Comprehensive guides and API reference</li> <li>GitHub Issues: Bug reports and feature requests</li> <li>Discussions: Community Q&amp;A and best practices</li> </ul>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>We welcome contributions! See our contribution guidelines for: - Code contributions - Documentation improvements - Bug reports and feature requests - Example workflows and tutorials</p>"},{"location":"index.html#license","title":"License","text":"<p>THEMAP is released under the MIT License. See LICENSE for details.</p>"},{"location":"index.html#whats-next","title":"What's Next?","text":"<ul> <li> <p>New to THEMAP?</p> <p>Start with our comprehensive getting started guide</p> <p> Getting started</p> </li> <li> <p>Want to compute distances?</p> <p>Learn about all available distance computation methods</p> <p> Distance computation</p> </li> <li> <p>Working with real data?</p> <p>Learn how to work with tasks and multi-modal data</p> <p> Working with Tasks</p> </li> <li> <p>Need inspiration?</p> <p>Browse our collection of examples and use cases</p> <p> Examples</p> </li> </ul>"},{"location":"api/data.html","title":"Data Module","text":"<p>The data module provides classes and utilities for loading, managing, and converting molecular and protein datasets.</p>"},{"location":"api/data.html#overview","title":"Overview","text":"<p>The data system consists of these main components:</p> <ul> <li><code>MoleculeDataset</code> - Container for molecular data (SMILES, labels)</li> <li><code>DatasetLoader</code> - Load datasets from directory structures</li> <li><code>CSVConverter</code> - Convert CSV files to JSONL.GZ format</li> <li><code>Tasks</code> - Unified task management across train/test/valid splits</li> </ul>"},{"location":"api/data.html#moleculedataset","title":"MoleculeDataset","text":""},{"location":"api/data.html#moleculedataset_1","title":"MoleculeDataset","text":""},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset","title":"themap.data.molecule_dataset.MoleculeDataset  <code>dataclass</code>","text":"<p>Simplified dataset structure for molecules.</p> <p>Optimized for batch distance computation between tasks. Stores SMILES strings and labels directly without per-molecule object overhead.</p> <p>Attributes:</p> Name Type Description <code>task_id</code> <code>str</code> <p>String identifying the task this dataset belongs to.</p> <code>smiles_list</code> <code>List[str]</code> <p>List of SMILES strings for all molecules.</p> <code>labels</code> <code>NDArray[int32]</code> <p>Binary labels as numpy array (0/1).</p> <code>numeric_labels</code> <code>Optional[NDArray[float32]]</code> <p>Optional continuous labels (e.g., pIC50).</p> <code>_features</code> <code>Optional[NDArray[float32]]</code> <p>Precomputed feature matrix (set via set_features or pipeline).</p> <code>_featurizer_name</code> <code>Optional[str]</code> <p>Name of featurizer used for current features.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dataset = MoleculeDataset.load_from_file(\"datasets/train/CHEMBL123.jsonl.gz\")\n&gt;&gt;&gt; print(len(dataset))  # Number of molecules\n&gt;&gt;&gt; print(dataset.positive_ratio)  # Ratio of positive labels\n&gt;&gt;&gt; # Features are set externally via FeaturizationPipeline\n&gt;&gt;&gt; dataset.set_features(features_array, \"ecfp\")\n&gt;&gt;&gt; pos_proto, neg_proto = dataset.get_prototype()\n</code></pre>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.smiles","title":"smiles  <code>property</code>","text":"<pre><code>smiles: List[str]\n</code></pre> <p>Get SMILES list (alias for backward compatibility).</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.positive_ratio","title":"positive_ratio  <code>property</code>","text":"<pre><code>positive_ratio: float\n</code></pre> <p>Get ratio of positive to total examples.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.features","title":"features  <code>property</code>","text":"<pre><code>features: Optional[NDArray[float32]]\n</code></pre> <p>Get precomputed features if available.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.featurizer_name","title":"featurizer_name  <code>property</code>","text":"<pre><code>featurizer_name: Optional[str]\n</code></pre> <p>Get name of featurizer used for current features.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.datapoints","title":"datapoints  <code>property</code>","text":"<pre><code>datapoints: List[Dict[str, Any]]\n</code></pre> <p>Legacy property for backward compatibility with metalearning module.</p> <p>Returns list of dictionaries with molecule data.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.data","title":"data  <code>property</code>","text":"<pre><code>data: List[Dict[str, Any]]\n</code></pre> <p>Legacy property - alias for datapoints.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate dataset initialization.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return number of molecules in the dataset.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.has_features","title":"has_features","text":"<pre><code>has_features() -&gt; bool\n</code></pre> <p>Check if features have been computed.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.set_features","title":"set_features","text":"<pre><code>set_features(features: NDArray[float32], featurizer_name: str) -&gt; None\n</code></pre> <p>Set precomputed features for this dataset.</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>NDArray[float32]</code> <p>Feature matrix of shape (n_molecules, feature_dim)</p> required <code>featurizer_name</code> <code>str</code> <p>Name of the featurizer used</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If feature dimensions don't match dataset size</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.clear_features","title":"clear_features","text":"<pre><code>clear_features() -&gt; None\n</code></pre> <p>Clear cached features to free memory.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.get_features","title":"get_features","text":"<pre><code>get_features(\n    featurizer_name: str = \"ecfp\", **kwargs: Any\n) -&gt; NDArray[np.float32]\n</code></pre> <p>Get molecular features, computing on demand if necessary.</p> <p>This method returns pre-computed features if available (set via set_features or FeaturizationPipeline), or computes features on demand using the specified featurizer.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>str</code> <p>Name of molecular featurizer to use (e.g., \"ecfp\", \"maccs\", \"desc2D\")</p> <code>'ecfp'</code> <code>**kwargs</code> <code>Any</code> <p>Additional featurizer arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Feature matrix of shape (n_molecules, feature_dim)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no molecules in dataset or featurization fails</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.get_prototype","title":"get_prototype","text":"<pre><code>get_prototype(\n    featurizer_name: Optional[str] = None,\n) -&gt; Tuple[NDArray[np.float32], NDArray[np.float32]]\n</code></pre> <p>Compute positive and negative prototypes from features.</p> <p>Prototypes are the mean feature vectors for each class.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>Optional[str]</code> <p>Optional featurizer name. If provided and features aren't yet computed, they will be computed on demand.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[NDArray[float32], NDArray[float32]]</code> <p>Tuple of (positive_prototype, negative_prototype)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If features haven't been set or no examples exist for a class</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.get_class_features","title":"get_class_features","text":"<pre><code>get_class_features() -&gt; Tuple[NDArray[np.float32], NDArray[np.float32]]\n</code></pre> <p>Get features separated by class.</p> <p>Returns:</p> Type Description <code>Tuple[NDArray[float32], NDArray[float32]]</code> <p>Tuple of (positive_features, negative_features)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If features haven't been set</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.load_from_file","title":"load_from_file  <code>staticmethod</code>","text":"<pre><code>load_from_file(path: Union[str, RichPath, Path]) -&gt; MoleculeDataset\n</code></pre> <p>Load dataset from a JSONL.GZ file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, RichPath, Path]</code> <p>Path to the JSONL.GZ file.</p> required <p>Returns:</p> Type Description <code>MoleculeDataset</code> <p>MoleculeDataset with loaded SMILES and labels.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert dataset to dictionary representation.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; MoleculeDataset\n</code></pre> <p>Create dataset from dictionary representation.</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.filter_by_indices","title":"filter_by_indices","text":"<pre><code>filter_by_indices(indices: List[int]) -&gt; MoleculeDataset\n</code></pre> <p>Create a new dataset with only the specified indices.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>List[int]</code> <p>List of indices to keep</p> required <p>Returns:</p> Type Description <code>MoleculeDataset</code> <p>New MoleculeDataset with filtered data</p>"},{"location":"api/data.html#themap.data.molecule_dataset.MoleculeDataset.get_statistics","title":"get_statistics","text":"<pre><code>get_statistics() -&gt; Dict[str, Any]\n</code></pre> <p>Get basic statistics about the dataset.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with dataset statistics</p>"},{"location":"api/data.html#usage-examples","title":"Usage Examples","text":"<pre><code>from themap.data import MoleculeDataset\n\n# Load from JSONL.GZ file\ndataset = MoleculeDataset.from_jsonl_gz(\"datasets/train/CHEMBL123456.jsonl.gz\")\n\nprint(f\"Number of molecules: {len(dataset)}\")\nprint(f\"SMILES: {dataset.smiles_list[:3]}\")\nprint(f\"Labels: {dataset.labels[:3]}\")\n</code></pre>"},{"location":"api/data.html#creating-from-data","title":"Creating from Data","text":"<pre><code>from themap.data import MoleculeDataset\n\n# Create from lists\ndataset = MoleculeDataset(\n    smiles_list=[\"CCO\", \"CCCO\", \"CC(=O)O\"],\n    labels=[1, 0, 1],\n    task_id=\"my_task\"\n)\n\n# Save to file\ndataset.to_jsonl_gz(\"output/my_task.jsonl.gz\")\n</code></pre>"},{"location":"api/data.html#datasetloader","title":"DatasetLoader","text":""},{"location":"api/data.html#datasetloader_1","title":"DatasetLoader","text":""},{"location":"api/data.html#themap.data.loader.DatasetLoader","title":"themap.data.loader.DatasetLoader","text":"<p>Load datasets from directory structure.</p> <p>Supports the following directory structure: <pre><code>data_dir/\n\u251c\u2500\u2500 train/           # Training tasks (source)\n\u2502   \u251c\u2500\u2500 TASK1.csv\n\u2502   \u251c\u2500\u2500 TASK2.jsonl.gz\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 test/            # Test tasks (target)\n\u2502   \u251c\u2500\u2500 TASK3.csv\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 valid/           # Optional validation tasks\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 proteins/        # Optional protein FASTA files\n\u2502   \u251c\u2500\u2500 TASK1.fasta\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 tasks.json       # Optional task list\n</code></pre></p> <p>If tasks.json is not provided, all CSV/JSONL.GZ files are auto-discovered.</p> <p>Attributes:</p> Name Type Description <code>data_dir</code> <p>Root directory containing train/test/valid folders.</p> <code>task_list</code> <code>Optional[Dict[str, List[str]]]</code> <p>Optional task list loaded from tasks.json.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; loader = DatasetLoader(Path(\"datasets/TDC\"))\n&gt;&gt;&gt; train_datasets = loader.load_datasets(\"train\")\n&gt;&gt;&gt; test_datasets = loader.load_datasets(\"test\")\n&gt;&gt;&gt; # Get task IDs\n&gt;&gt;&gt; train_ids = list(train_datasets.keys())\n</code></pre>"},{"location":"api/data.html#themap.data.loader.DatasetLoader.__init__","title":"__init__","text":"<pre><code>__init__(data_dir: Union[str, Path], task_list_file: Optional[str] = None)\n</code></pre> <p>Initialize the dataset loader.</p> <p>Parameters:</p> Name Type Description Default <code>data_dir</code> <code>Union[str, Path]</code> <p>Root directory containing train/test/valid folders.</p> required <code>task_list_file</code> <code>Optional[str]</code> <p>Optional name of task list JSON file in data_dir.            If None, all files are auto-discovered.</p> <code>None</code>"},{"location":"api/data.html#themap.data.loader.DatasetLoader.get_fold_dir","title":"get_fold_dir","text":"<pre><code>get_fold_dir(fold: str) -&gt; Path\n</code></pre> <p>Get the directory for a specific fold.</p> <p>Parameters:</p> Name Type Description Default <code>fold</code> <code>str</code> <p>Fold name (train, test, or valid).</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the fold directory.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fold name is invalid.</p>"},{"location":"api/data.html#themap.data.loader.DatasetLoader.get_task_ids","title":"get_task_ids","text":"<pre><code>get_task_ids(fold: str) -&gt; List[str]\n</code></pre> <p>Get list of task IDs for a fold.</p> <p>If task_list is provided, uses that. Otherwise auto-discovers files.</p> <p>Parameters:</p> Name Type Description Default <code>fold</code> <code>str</code> <p>Fold name (train, test, or valid).</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of task IDs.</p>"},{"location":"api/data.html#themap.data.loader.DatasetLoader.load_dataset","title":"load_dataset","text":"<pre><code>load_dataset(\n    fold: str, task_id: str, convert_csv: bool = True\n) -&gt; MoleculeDataset\n</code></pre> <p>Load a single dataset.</p> <p>Parameters:</p> Name Type Description Default <code>fold</code> <code>str</code> <p>Fold name (train, test, or valid).</p> required <code>task_id</code> <code>str</code> <p>Task ID to load.</p> required <code>convert_csv</code> <code>bool</code> <p>If True, convert CSV to JSONL.GZ format automatically.</p> <code>True</code> <p>Returns:</p> Type Description <code>MoleculeDataset</code> <p>MoleculeDataset instance.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If dataset file not found.</p>"},{"location":"api/data.html#themap.data.loader.DatasetLoader.load_datasets","title":"load_datasets","text":"<pre><code>load_datasets(\n    fold: str, task_ids: Optional[List[str]] = None, convert_csv: bool = True\n) -&gt; Dict[str, MoleculeDataset]\n</code></pre> <p>Load all datasets for a fold.</p> <p>Parameters:</p> Name Type Description Default <code>fold</code> <code>str</code> <p>Fold name (train, test, or valid).</p> required <code>task_ids</code> <code>Optional[List[str]]</code> <p>Optional list of specific task IDs to load.      If None, loads all tasks in the fold.</p> <code>None</code> <code>convert_csv</code> <code>bool</code> <p>If True, convert CSV to JSONL.GZ format automatically.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, MoleculeDataset]</code> <p>Dictionary mapping task IDs to MoleculeDataset instances.</p>"},{"location":"api/data.html#themap.data.loader.DatasetLoader.load_all_folds","title":"load_all_folds","text":"<pre><code>load_all_folds(\n    convert_csv: bool = True,\n) -&gt; Dict[str, Dict[str, MoleculeDataset]]\n</code></pre> <p>Load datasets from all available folds.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, MoleculeDataset]]</code> <p>Dictionary mapping fold names to dictionaries of datasets.</p>"},{"location":"api/data.html#themap.data.loader.DatasetLoader.get_protein_file","title":"get_protein_file","text":"<pre><code>get_protein_file(task_id: str) -&gt; Optional[Path]\n</code></pre> <p>Get path to protein FASTA file for a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>Task ID to find protein for.</p> required <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Path to FASTA file, or None if not found.</p>"},{"location":"api/data.html#themap.data.loader.DatasetLoader.load_protein_sequences","title":"load_protein_sequences","text":"<pre><code>load_protein_sequences() -&gt; Dict[str, str]\n</code></pre> <p>Load all protein sequences from the proteins directory.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dictionary mapping task IDs to protein sequences.</p>"},{"location":"api/data.html#themap.data.loader.DatasetLoader.get_statistics","title":"get_statistics","text":"<pre><code>get_statistics() -&gt; Dict[str, Any]\n</code></pre> <p>Get statistics about available datasets.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with dataset counts and information.</p>"},{"location":"api/data.html#usage-examples_1","title":"Usage Examples","text":"<pre><code>from themap.data import DatasetLoader\n\n# Initialize loader\nloader = DatasetLoader(\n    data_dir=\"datasets\",\n    task_list_file=\"datasets/sample_tasks_list.json\"\n)\n\n# Load all datasets\ntrain_datasets = loader.load_fold(\"train\")\ntest_datasets = loader.load_fold(\"test\")\n\nprint(f\"Loaded {len(train_datasets)} training datasets\")\nprint(f\"Loaded {len(test_datasets)} test datasets\")\n</code></pre>"},{"location":"api/data.html#loading-specific-tasks","title":"Loading Specific Tasks","text":"<pre><code>from themap.data import DatasetLoader\n\nloader = DatasetLoader(data_dir=\"datasets\")\n\n# Load specific dataset\ndataset = loader.load_dataset(\n    task_id=\"CHEMBL123456\",\n    fold=\"train\"\n)\n\n# Load multiple datasets\ndatasets = loader.load_datasets(\n    task_ids=[\"CHEMBL123456\", \"CHEMBL789012\"],\n    fold=\"train\"\n)\n</code></pre>"},{"location":"api/data.html#get-dataset-statistics","title":"Get Dataset Statistics","text":"<pre><code>from themap.data import DatasetLoader\n\nloader = DatasetLoader(data_dir=\"datasets\")\nstats = loader.get_statistics()\n\nprint(f\"Data directory: {stats['data_dir']}\")\nfor fold, fold_stats in stats['folds'].items():\n    print(f\"  {fold}: {fold_stats['task_count']} tasks\")\n</code></pre>"},{"location":"api/data.html#csvconverter","title":"CSVConverter","text":""},{"location":"api/data.html#csvconverter_1","title":"CSVConverter","text":""},{"location":"api/data.html#themap.data.converter.CSVConverter","title":"themap.data.converter.CSVConverter","text":"<p>Convert CSV files to JSONL.GZ format for THEMAP.</p> <p>Supports auto-detection of SMILES and activity columns, RDKit-based SMILES validation, and various CSV formats.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; converter = CSVConverter()\n&gt;&gt;&gt; stats = converter.convert(\"input.csv\", \"output.jsonl.gz\", \"CHEMBL123\")\n&gt;&gt;&gt; print(f\"Converted {stats.valid_molecules} molecules\")\n</code></pre>"},{"location":"api/data.html#themap.data.converter.CSVConverter.__init__","title":"__init__","text":"<pre><code>__init__(\n    validate_smiles: bool = True,\n    strict_validation: bool = True,\n    auto_detect_columns: bool = True,\n)\n</code></pre> <p>Initialize the converter.</p> <p>Parameters:</p> Name Type Description Default <code>validate_smiles</code> <code>bool</code> <p>Whether to validate SMILES with RDKit.</p> <code>True</code> <code>strict_validation</code> <code>bool</code> <p>If True, use strict sanitization.</p> <code>True</code> <code>auto_detect_columns</code> <code>bool</code> <p>If True, auto-detect column names.</p> <code>True</code>"},{"location":"api/data.html#themap.data.converter.CSVConverter.read_csv","title":"read_csv","text":"<pre><code>read_csv(\n    path: Union[str, Path],\n    smiles_column: Optional[str] = None,\n    activity_column: Optional[str] = None,\n) -&gt; Dict[str, Any]\n</code></pre> <p>Read CSV file and extract SMILES and labels.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the CSV file.</p> required <code>smiles_column</code> <code>Optional[str]</code> <p>Name of the SMILES column (auto-detected if None).</p> <code>None</code> <code>activity_column</code> <code>Optional[str]</code> <p>Name of the activity column (auto-detected if None).</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with 'smiles', 'labels', 'numeric_labels' keys.</p>"},{"location":"api/data.html#themap.data.converter.CSVConverter.convert","title":"convert","text":"<pre><code>convert(\n    input_path: Union[str, Path],\n    output_path: Union[str, Path],\n    task_id: str,\n    smiles_column: Optional[str] = None,\n    activity_column: Optional[str] = None,\n) -&gt; ConversionStats\n</code></pre> <p>Convert CSV file to JSONL.GZ format.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>Union[str, Path]</code> <p>Path to input CSV file.</p> required <code>output_path</code> <code>Union[str, Path]</code> <p>Path for output JSONL.GZ file.</p> required <code>task_id</code> <code>str</code> <p>Task/assay ID for the dataset.</p> required <code>smiles_column</code> <code>Optional[str]</code> <p>Name of SMILES column (auto-detected if None).</p> <code>None</code> <code>activity_column</code> <code>Optional[str]</code> <p>Name of activity column (auto-detected if None).</p> <code>None</code> <p>Returns:</p> Type Description <code>ConversionStats</code> <p>ConversionStats with conversion statistics.</p>"},{"location":"api/data.html#usage-examples_2","title":"Usage Examples","text":"<pre><code>from themap.data.converter import CSVConverter\nfrom pathlib import Path\n\n# Initialize converter\nconverter = CSVConverter(\n    validate_smiles=True,\n    auto_detect_columns=True\n)\n\n# Convert a CSV file\nstats = converter.convert(\n    input_path=Path(\"data/raw.csv\"),\n    output_path=Path(\"datasets/train/CHEMBL123456.jsonl.gz\"),\n    task_id=\"CHEMBL123456\"\n)\n\nprint(f\"Converted {stats.valid_molecules}/{stats.total_rows} molecules\")\nprint(f\"Success rate: {stats.success_rate:.1f}%\")\n</code></pre>"},{"location":"api/data.html#specifying-column-names","title":"Specifying Column Names","text":"<pre><code>from themap.data.converter import CSVConverter\nfrom pathlib import Path\n\nconverter = CSVConverter(validate_smiles=True)\n\nstats = converter.convert(\n    input_path=Path(\"data.csv\"),\n    output_path=Path(\"output.jsonl.gz\"),\n    task_id=\"my_task\",\n    smiles_column=\"canonical_smiles\",\n    activity_column=\"pIC50\"\n)\n</code></pre>"},{"location":"api/data.html#batch-conversion","title":"Batch Conversion","text":"<pre><code>from themap.data.converter import CSVConverter\nfrom pathlib import Path\n\nconverter = CSVConverter()\n\n# Convert multiple files\ncsv_files = Path(\"raw_data\").glob(\"*.csv\")\n\nfor csv_file in csv_files:\n    task_id = csv_file.stem\n    output_path = Path(f\"datasets/train/{task_id}.jsonl.gz\")\n\n    stats = converter.convert(csv_file, output_path, task_id)\n    print(f\"{task_id}: {stats.valid_molecules} molecules\")\n</code></pre>"},{"location":"api/data.html#tasks","title":"Tasks","text":""},{"location":"api/data.html#tasks_1","title":"Tasks","text":""},{"location":"api/data.html#themap.data.tasks.Tasks","title":"themap.data.tasks.Tasks","text":"<p>Collection of tasks for molecular property prediction across different folds.</p> <p>This class manages multiple Task objects and provides unified access to molecular, protein, and metadata features across train/validation/test splits.</p>"},{"location":"api/data.html#themap.data.tasks.Tasks.__init__","title":"__init__","text":"<pre><code>__init__(\n    train_tasks: Optional[List[Task]] = None,\n    valid_tasks: Optional[List[Task]] = None,\n    test_tasks: Optional[List[Task]] = None,\n    cache_dir: Optional[Union[str, Path]] = None,\n) -&gt; None\n</code></pre> <p>Initialize Tasks collection.</p> <p>Parameters:</p> Name Type Description Default <code>train_tasks</code> <code>Optional[List[Task]]</code> <p>List of training tasks</p> <code>None</code> <code>valid_tasks</code> <code>Optional[List[Task]]</code> <p>List of validation tasks</p> <code>None</code> <code>test_tasks</code> <code>Optional[List[Task]]</code> <p>List of test tasks</p> <code>None</code> <code>cache_dir</code> <code>Optional[Union[str, Path]]</code> <p>Directory for persistent caching</p> <code>None</code>"},{"location":"api/data.html#themap.data.tasks.Tasks.from_directory","title":"from_directory  <code>staticmethod</code>","text":"<pre><code>from_directory(\n    directory: Union[str, RichPath],\n    task_list_file: Optional[Union[str, RichPath]] = None,\n    cache_dir: Optional[Union[str, Path]] = None,\n    load_molecules: bool = True,\n    load_proteins: bool = True,\n    load_metadata: bool = True,\n    metadata_types: Optional[List[str]] = None,\n    **kwargs: Any,\n) -&gt; Tasks\n</code></pre> <p>Create Tasks from a directory structure.</p> <p>Expected directory structure: directory/ \u251c\u2500\u2500 train/ \u2502   \u251c\u2500\u2500 CHEMBL123.jsonl.gz (molecules) \u2502   \u251c\u2500\u2500 CHEMBL123.fasta (proteins) \u2502   \u251c\u2500\u2500 CHEMBL123_assay.json (metadata) \u2502   \u2514\u2500\u2500 ... \u251c\u2500\u2500 valid/ \u2514\u2500\u2500 test/</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Union[str, RichPath]</code> <p>Base directory containing task data</p> required <code>task_list_file</code> <code>Optional[Union[str, RichPath]]</code> <p>JSON file with fold-specific task lists</p> <code>None</code> <code>cache_dir</code> <code>Optional[Union[str, Path]]</code> <p>Directory for persistent caching</p> <code>None</code> <code>load_molecules</code> <code>bool</code> <p>Whether to load molecular data</p> <code>True</code> <code>load_proteins</code> <code>bool</code> <p>Whether to load protein data</p> <code>True</code> <code>load_metadata</code> <code>bool</code> <p>Whether to load metadata</p> <code>True</code> <code>metadata_types</code> <code>Optional[List[str]]</code> <p>List of metadata types to load</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tasks</code> <p>Tasks instance with loaded data</p>"},{"location":"api/data.html#themap.data.tasks.Tasks.get_num_fold_tasks","title":"get_num_fold_tasks","text":"<pre><code>get_num_fold_tasks(fold: DataFold) -&gt; int\n</code></pre> <p>Get number of tasks in a specific fold.</p>"},{"location":"api/data.html#themap.data.tasks.Tasks.get_task_ids","title":"get_task_ids","text":"<pre><code>get_task_ids(fold: DataFold) -&gt; List[str]\n</code></pre> <p>Get list of task IDs in a specific fold.</p>"},{"location":"api/data.html#themap.data.tasks.Tasks.get_tasks","title":"get_tasks","text":"<pre><code>get_tasks(fold: DataFold) -&gt; List[Task]\n</code></pre> <p>Get list of tasks in a specific fold.</p>"},{"location":"api/data.html#themap.data.tasks.Tasks.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Get number of tasks.</p>"},{"location":"api/data.html#themap.data.tasks.Tasks.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; List[Task]\n</code></pre> <p>Get a task by index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>int: index of the task</p> required <p>Returns:</p> Type Description <code>List[Task]</code> <p>List[Task]: list of tasks</p> Note <p>index 0: Train Tasks index 1: Validation Tasks index 2: Test Tasks</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>if index is out of range</p>"},{"location":"api/data.html#themap.data.tasks.Tasks.get_task_by_id","title":"get_task_by_id","text":"<pre><code>get_task_by_id(task_id: str) -&gt; Optional[Task]\n</code></pre> <p>Get a specific task by its ID.</p>"},{"location":"api/data.html#themap.data.tasks.Tasks.compute_all_task_features","title":"compute_all_task_features","text":"<pre><code>compute_all_task_features(\n    molecule_featurizer: Optional[str] = None,\n    protein_featurizer: Optional[str] = None,\n    metadata_configs: Optional[Dict[str, Dict[str, Any]]] = None,\n    combination_method: str = \"concatenate\",\n    folds: Optional[List[DataFold]] = None,\n    force_recompute: bool = False,\n    **kwargs: Any,\n) -&gt; Dict[str, NDArray[np.float32]]\n</code></pre> <p>Compute combined features for all tasks.</p> <p>Parameters:</p> Name Type Description Default <code>molecule_featurizer</code> <code>Optional[str]</code> <p>Molecular featurizer name</p> <code>None</code> <code>protein_featurizer</code> <code>Optional[str]</code> <p>Protein featurizer name</p> <code>None</code> <code>metadata_configs</code> <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>Metadata featurizer configurations</p> <code>None</code> <code>combination_method</code> <code>str</code> <p>How to combine features</p> <code>'concatenate'</code> <code>folds</code> <code>Optional[List[DataFold]]</code> <p>List of folds to process</p> <code>None</code> <code>force_recompute</code> <code>bool</code> <p>Whether to force recomputation</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, NDArray[float32]]</code> <p>Dictionary mapping task names to combined features</p>"},{"location":"api/data.html#themap.data.tasks.Tasks.get_distance_computation_ready_features","title":"get_distance_computation_ready_features","text":"<pre><code>get_distance_computation_ready_features(\n    molecule_featurizer: Optional[str] = None,\n    protein_featurizer: Optional[str] = None,\n    metadata_configs: Optional[Dict[str, Dict[str, Any]]] = None,\n    combination_method: str = \"concatenate\",\n    source_fold: DataFold = DataFold.TRAIN,\n    target_folds: Optional[List[DataFold]] = None,\n    **kwargs: Any,\n) -&gt; Tuple[\n    List[NDArray[np.float32]], List[NDArray[np.float32]], List[str], List[str]\n]\n</code></pre> <p>Get task features organized for efficient N\u00d7M distance matrix computation.</p> <p>Parameters:</p> Name Type Description Default <code>molecule_featurizer</code> <code>Optional[str]</code> <p>Molecular featurizer name</p> <code>None</code> <code>protein_featurizer</code> <code>Optional[str]</code> <p>Protein featurizer name</p> <code>None</code> <code>metadata_configs</code> <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>Metadata featurizer configurations</p> <code>None</code> <code>combination_method</code> <code>str</code> <p>How to combine features</p> <code>'concatenate'</code> <code>source_fold</code> <code>DataFold</code> <p>Fold to use as source tasks (N)</p> <code>TRAIN</code> <code>target_folds</code> <code>Optional[List[DataFold]]</code> <p>Folds to use as target tasks (M)</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[NDArray[float32]]</code> <p>Tuple containing:</p> <code>List[NDArray[float32]]</code> <ul> <li>source_features: List of feature arrays for source tasks</li> </ul> <code>List[str]</code> <ul> <li>target_features: List of feature arrays for target tasks</li> </ul> <code>List[str]</code> <ul> <li>source_names: List of source task names</li> </ul> <code>Tuple[List[NDArray[float32]], List[NDArray[float32]], List[str], List[str]]</code> <ul> <li>target_names: List of target task names</li> </ul>"},{"location":"api/data.html#themap.data.tasks.Tasks.save_task_features_to_file","title":"save_task_features_to_file","text":"<pre><code>save_task_features_to_file(\n    output_path: Union[str, Path],\n    molecule_featurizer: Optional[str] = None,\n    protein_featurizer: Optional[str] = None,\n    metadata_configs: Optional[Dict[str, Dict[str, Any]]] = None,\n    combination_method: str = \"concatenate\",\n    folds: Optional[List[DataFold]] = None,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Save computed task features to a pickle file for efficient loading.</p>"},{"location":"api/data.html#themap.data.tasks.Tasks.load_task_features_from_file","title":"load_task_features_from_file  <code>staticmethod</code>","text":"<pre><code>load_task_features_from_file(\n    file_path: Union[str, Path],\n) -&gt; Dict[str, NDArray[np.float32]]\n</code></pre> <p>Load precomputed task features from a pickle file.</p>"},{"location":"api/data.html#themap.data.tasks.Tasks.get_cache_stats","title":"get_cache_stats","text":"<pre><code>get_cache_stats() -&gt; Dict[str, Any]\n</code></pre> <p>Get statistics about feature caching.</p>"},{"location":"api/data.html#usage-examples_3","title":"Usage Examples","text":"<pre><code>from themap.data.tasks import Tasks\n\n# Load tasks from directory\ntasks = Tasks.from_directory(\n    directory=\"datasets/\",\n    task_list_file=\"datasets/sample_tasks_list.json\",\n    load_molecules=True,\n    load_proteins=True\n)\n\nprint(f\"Train tasks: {tasks.get_num_fold_tasks('TRAIN')}\")\nprint(f\"Test tasks: {tasks.get_num_fold_tasks('TEST')}\")\n</code></pre>"},{"location":"api/data.html#accessing-tasks","title":"Accessing Tasks","text":"<pre><code># Get task IDs by fold\ntrain_ids = tasks.get_task_ids(fold=\"TRAIN\")\ntest_ids = tasks.get_task_ids(fold=\"TEST\")\n\n# Get specific task\ntask = tasks.get_task(\"CHEMBL123456\")\nprint(f\"Task {task.task_id}: {len(task.molecule_dataset)} molecules\")\n</code></pre>"},{"location":"api/data.html#working-with-features","title":"Working with Features","text":"<pre><code># Compute features for all tasks\nall_features = tasks.compute_all_task_features(\n    molecule_featurizer=\"ecfp\",\n    protein_featurizer=\"esm2_t33_650M_UR50D\",\n    folds=[\"TRAIN\", \"TEST\"]\n)\n\n# Get features ready for distance computation\nsource_features, target_features, source_names, target_names = (\n    tasks.get_distance_computation_ready_features(\n        molecule_featurizer=\"ecfp\",\n        source_fold=\"TRAIN\",\n        target_folds=[\"TEST\"]\n    )\n)\n</code></pre>"},{"location":"api/data.html#task-class","title":"Task Class","text":""},{"location":"api/data.html#task","title":"Task","text":""},{"location":"api/data.html#themap.data.tasks.Task","title":"themap.data.tasks.Task  <code>dataclass</code>","text":"<p>A task represents a complete molecular property prediction problem.</p> <p>Each task contains: - Dataset: MoleculeDataset (set of molecules with SMILES and labels) - Metadata: Various metadata types including protein (single vectors per task)</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>Unique identifier for the task (e.g., CHEMBL ID)</p> required <code>molecule_dataset</code> <code>Optional[MoleculeDataset]</code> <p>THE dataset - set of molecules for this task</p> <code>None</code> <code>metadata_datasets</code> <code>Optional[Dict[str, Any]]</code> <p>Dictionary of metadata by type - Can include \"protein\" for protein metadata (single vector per task) - Can include \"assay_description\", \"target_info\", etc.</p> <code>None</code> <code>hardness</code> <code>Optional[float]</code> <p>Optional measure of task difficulty</p> <code>None</code> Note <p>protein_dataset is deprecated - protein data should be stored in metadata_datasets[\"protein\"]</p>"},{"location":"api/data.html#themap.data.tasks.Task.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate task initialization and handle backward compatibility.</p>"},{"location":"api/data.html#themap.data.tasks.Task.get_molecule_features","title":"get_molecule_features","text":"<pre><code>get_molecule_features(\n    featurizer_name: str, **kwargs: Any\n) -&gt; Optional[NDArray[np.float32]]\n</code></pre> <p>Get molecular features for this task.</p> <p>This method returns pre-computed features if available (set via set_features or FeaturizationPipeline), or computes features on demand using the specified featurizer.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>str</code> <p>Name of molecular featurizer to use</p> required <code>**kwargs</code> <code>Any</code> <p>Additional featurizer arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[NDArray[float32]]</code> <p>Molecular features or None if no molecule data</p>"},{"location":"api/data.html#themap.data.tasks.Task.get_protein_features","title":"get_protein_features","text":"<pre><code>get_protein_features(\n    featurizer_name: str = \"esm2_t33_650M_UR50D\", layer: int = 33, **kwargs: Any\n) -&gt; Optional[NDArray[np.float32]]\n</code></pre> <p>Get protein features for this task.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>str</code> <p>Name of protein featurizer to use</p> <code>'esm2_t33_650M_UR50D'</code> <code>layer</code> <code>int</code> <p>Layer number for ESM models</p> <code>33</code> <code>**kwargs</code> <code>Any</code> <p>Additional featurizer arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[NDArray[float32]]</code> <p>Protein features or None if no protein data</p>"},{"location":"api/data.html#themap.data.tasks.Task.get_metadata_features","title":"get_metadata_features","text":"<pre><code>get_metadata_features(\n    metadata_type: str, featurizer_name: str, **kwargs: Any\n) -&gt; Optional[NDArray[np.float32]]\n</code></pre> <p>Get metadata features for this task.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_type</code> <code>str</code> <p>Type of metadata to get features for</p> required <code>featurizer_name</code> <code>str</code> <p>Name of metadata featurizer to use</p> required <code>**kwargs</code> <code>Any</code> <p>Additional featurizer arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[NDArray[float32]]</code> <p>Metadata features or None if metadata type not available</p>"},{"location":"api/data.html#themap.data.tasks.Task.get_combined_features","title":"get_combined_features","text":"<pre><code>get_combined_features(\n    molecule_featurizer: Optional[str] = None,\n    protein_featurizer: Optional[str] = None,\n    metadata_configs: Optional[Dict[str, Dict[str, Any]]] = None,\n    combination_method: str = \"concatenate\",\n    **kwargs: Any,\n) -&gt; NDArray[np.float32]\n</code></pre> <p>Get combined features from all available data types.</p> <p>Parameters:</p> Name Type Description Default <code>molecule_featurizer</code> <code>Optional[str]</code> <p>Molecular featurizer name</p> <code>None</code> <code>protein_featurizer</code> <code>Optional[str]</code> <p>Protein featurizer name</p> <code>None</code> <code>metadata_configs</code> <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>Dict mapping metadata types to featurizer configs</p> <code>None</code> <code>combination_method</code> <code>str</code> <p>How to combine features ('concatenate', 'average', 'weighted_average')</p> <code>'concatenate'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Combined feature vector</p>"},{"location":"api/data.html#themap.data.tasks.Task.get_task_embedding","title":"get_task_embedding","text":"<pre><code>get_task_embedding(data_model: Any, metadata_model: Any) -&gt; NDArray[np.float32]\n</code></pre> <p>Legacy method for backward compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>data_model</code> <code>Any</code> <p>Model for data feature extraction</p> required <code>metadata_model</code> <code>Any</code> <p>Model for metadata feature extraction</p> required <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Combined feature vector</p>"},{"location":"api/data.html#themap.data.tasks.Task.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Get number of tasks.</p>"},{"location":"api/data.html#usage-examples_4","title":"Usage Examples","text":"<pre><code>from themap.data.tasks import Task\n\n# Access task data\ntask = tasks.get_task(\"CHEMBL123456\")\n\n# Molecular data\nif task.molecule_dataset:\n    smiles = task.molecule_dataset.smiles_list\n    labels = task.molecule_dataset.labels\n\n# Protein data\nif task.protein_dataset:\n    sequences = task.protein_dataset.sequences\n\n# Get features\nmol_features = task.get_molecule_features(\"ecfp\")\nprot_features = task.get_protein_features(\"esm2_t33_650M_UR50D\")\n</code></pre>"},{"location":"api/data.html#torchdataset","title":"TorchDataset","text":""},{"location":"api/data.html#torchmoleculedataset","title":"TorchMoleculeDataset","text":""},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset","title":"themap.data.torch_dataset.TorchMoleculeDataset","text":"<p>               Bases: <code>Dataset</code></p> <p>Enhanced PyTorch Dataset wrapper for molecular data.</p> <p>This class wraps a MoleculeDataset to provide PyTorch Dataset functionality while maintaining access to all original MoleculeDataset methods through delegation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>MoleculeDataset</code> <p>MoleculeDataset object</p> required <code>transform</code> <code>callable</code> <p>Transform to apply to features</p> <code>None</code> <code>target_transform</code> <code>callable</code> <p>Transform to apply to labels</p> <code>None</code> <code>lazy_loading</code> <code>bool</code> <p>Whether to load data lazily. Defaults to False.</p> <code>False</code> Example <p>from themap.data import MoleculeDataset from themap.data.torch_dataset import TorchMoleculeDataset</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset--load-molecular-dataset","title":"Load molecular dataset","text":"<p>mol_dataset = MoleculeDataset.load_from_file(\"data.jsonl.gz\")</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset--create-pytorch-wrapper","title":"Create PyTorch wrapper","text":"<p>torch_dataset = TorchMoleculeDataset(mol_dataset)</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset--use-as-pytorch-dataset","title":"Use as PyTorch Dataset","text":"<p>dataloader = torch.utils.data.DataLoader(torch_dataset, batch_size=32)</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset--access-original-methods-through-delegation","title":"Access original methods through delegation","text":"<p>stats = torch_dataset.get_statistics() features = torch_dataset.get_features(\"ecfp\")</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset.dataset","title":"dataset  <code>property</code>","text":"<pre><code>dataset: MoleculeDataset\n</code></pre> <p>Access to the underlying MoleculeDataset.</p> <p>Returns:</p> Name Type Description <code>MoleculeDataset</code> <code>MoleculeDataset</code> <p>The wrapped dataset</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset.__init__","title":"__init__","text":"<pre><code>__init__(\n    data: MoleculeDataset,\n    transform: Optional[Callable] = None,\n    target_transform: Optional[Callable] = None,\n    lazy_loading: bool = False,\n) -&gt; None\n</code></pre> <p>Initialize TorchMoleculeDataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>MoleculeDataset</code> <p>Input molecular dataset</p> required <code>transform</code> <code>callable</code> <p>Transform to apply to features</p> <code>None</code> <code>target_transform</code> <code>callable</code> <p>Transform to apply to labels</p> <code>None</code> <code>lazy_loading</code> <code>bool</code> <p>Whether to load tensors lazily</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dataset is empty or features/labels are invalid</p> <code>TypeError</code> <p>If data is not a MoleculeDataset instance</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; tuple[torch.Tensor, torch.Tensor]\n</code></pre> <p>Get a data sample.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the sample to get</p> required <p>Returns:</p> Type Description <code>tuple[Tensor, Tensor]</code> <p>tuple[torch.Tensor, torch.Tensor]: Tuple of (features, label)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If index is out of bounds</p> <code>RuntimeError</code> <p>If lazy loading fails</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Get the number of samples in the dataset.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of samples</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>String representation of the dataset.</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: str) -&gt; Any\n</code></pre> <p>Delegate attribute access to underlying MoleculeDataset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The attribute from the underlying dataset</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If attribute doesn't exist in underlying dataset</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset.get_smiles","title":"get_smiles","text":"<pre><code>get_smiles() -&gt; list[str]\n</code></pre> <p>Get SMILES strings for all molecules.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of SMILES strings</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset.refresh_tensors","title":"refresh_tensors","text":"<pre><code>refresh_tensors() -&gt; None\n</code></pre> <p>Refresh cached tensors from the underlying dataset.</p> <p>Useful when the underlying dataset has been modified.</p>"},{"location":"api/data.html#themap.data.torch_dataset.TorchMoleculeDataset.create_dataloader","title":"create_dataloader  <code>classmethod</code>","text":"<pre><code>create_dataloader(\n    data: MoleculeDataset,\n    batch_size: int = 64,\n    shuffle: bool = True,\n    transform: Optional[Callable] = None,\n    target_transform: Optional[Callable] = None,\n    lazy_loading: bool = False,\n    **kwargs: Any,\n) -&gt; torch.utils.data.DataLoader\n</code></pre> <p>Create PyTorch DataLoader with enhanced options.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>MoleculeDataset</code> <p>Input molecular dataset</p> required <code>batch_size</code> <code>int</code> <p>Batch size</p> <code>64</code> <code>shuffle</code> <code>bool</code> <p>Whether to shuffle data</p> <code>True</code> <code>transform</code> <code>Optional[Callable]</code> <p>Transform to apply to features</p> <code>None</code> <code>target_transform</code> <code>Optional[Callable]</code> <p>Transform to apply to labels</p> <code>None</code> <code>lazy_loading</code> <code>bool</code> <p>Whether to use lazy loading</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for DataLoader</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>DataLoader</code> <code>DataLoader</code> <p>PyTorch data loader</p> Example <p>loader = TorchMoleculeDataset.create_dataloader( ...     dataset, ...     batch_size=32, ...     shuffle=True, ...     num_workers=4 ... )</p>"},{"location":"api/data.html#usage-examples_5","title":"Usage Examples","text":"<pre><code>from themap.data.torch_dataset import TorchMoleculeDataset\nfrom torch.utils.data import DataLoader\n\n# Create PyTorch dataset\ntorch_dataset = TorchMoleculeDataset(\n    dataset=molecule_dataset,\n    featurizer=\"ecfp\"\n)\n\n# Use with DataLoader\ndataloader = DataLoader(\n    torch_dataset,\n    batch_size=32,\n    shuffle=True\n)\n\nfor batch in dataloader:\n    features, labels = batch\n    # Train your model...\n</code></pre>"},{"location":"api/data.html#data-format","title":"Data Format","text":""},{"location":"api/data.html#jsonlgz-format","title":"JSONL.GZ Format","text":"<p>THEMAP uses compressed JSON Lines format for molecular data:</p> <pre><code>{\"SMILES\": \"CCO\", \"Property\": 1}\n{\"SMILES\": \"CCCO\", \"Property\": 0}\n{\"SMILES\": \"CC(=O)O\", \"Property\": 1}\n</code></pre>"},{"location":"api/data.html#directory-structure","title":"Directory Structure","text":"<pre><code>datasets/\n\u251c\u2500\u2500 sample_tasks_list.json      # Task organization\n\u251c\u2500\u2500 train/\n\u2502   \u251c\u2500\u2500 CHEMBL123456.jsonl.gz   # Molecular data\n\u2502   \u251c\u2500\u2500 CHEMBL123456.fasta      # Protein sequences\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 test/\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 valid/\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"api/data.html#task-list-format","title":"Task List Format","text":"<pre><code>{\n    \"train\": [\"CHEMBL123456\", \"CHEMBL789012\", ...],\n    \"test\": [\"CHEMBL111111\", \"CHEMBL222222\", ...],\n    \"valid\": [\"CHEMBL333333\", ...]\n}\n</code></pre>"},{"location":"api/data.html#utility-functions","title":"Utility Functions","text":""},{"location":"api/data.html#validation","title":"Validation","text":"<pre><code>from themap.data.molecule_dataset import validate_smiles\n\n# Validate a SMILES string\nis_valid = validate_smiles(\"CCO\")\nprint(f\"Valid: {is_valid}\")  # True\n\nis_valid = validate_smiles(\"invalid\")\nprint(f\"Valid: {is_valid}\")  # False\n</code></pre>"},{"location":"api/data.html#canonicalization","title":"Canonicalization","text":"<pre><code>from themap.data.molecule_dataset import canonicalize_smiles\n\n# Canonicalize SMILES\ncanonical = canonicalize_smiles(\"C(C)O\")\nprint(canonical)  # \"CCO\"\n</code></pre>"},{"location":"api/data.html#error-handling","title":"Error Handling","text":"<pre><code>from themap.data import DatasetLoader, MoleculeDataset\n\ntry:\n    loader = DatasetLoader(data_dir=\"datasets\")\n    dataset = loader.load_dataset(\"CHEMBL123456\", fold=\"train\")\nexcept FileNotFoundError:\n    print(\"Dataset file not found\")\nexcept ValueError as e:\n    print(f\"Invalid data format: {e}\")\n</code></pre>"},{"location":"api/data.html#performance-tips","title":"Performance Tips","text":"<ol> <li>Lazy loading: Use <code>DatasetLoader</code> to load datasets on demand</li> <li>Caching: Enable feature caching for repeated computations</li> <li>Batch processing: Process datasets in batches for memory efficiency</li> <li>Parallel loading: Use <code>n_jobs</code> parameter for parallel dataset loading</li> </ol> <pre><code>from themap.data import DatasetLoader\n\n# Parallel loading\nloader = DatasetLoader(data_dir=\"datasets\", n_jobs=8)\ndatasets = loader.load_all_folds()\n</code></pre>"},{"location":"api/distance.html","title":"Distance Computation API","text":"<p>The distance module provides comprehensive functionality for computing distances between molecular datasets, protein datasets, and tasks. This module supports various distance metrics and can handle both single dataset comparisons and batch comparisons across multiple datasets.</p>"},{"location":"api/distance.html#overview","title":"Overview","text":"<p>The distance computation system consists of three main classes:</p> <ul> <li><code>MoleculeDatasetDistance</code> - Computes distances between molecule datasets</li> <li><code>ProteinDatasetDistance</code> - Computes distances between protein datasets</li> <li><code>TaskDistance</code> - Unified interface for computing combined task distances</li> </ul>"},{"location":"api/distance.html#core-classes","title":"Core Classes","text":""},{"location":"api/distance.html#abstracttasksdistance","title":"AbstractTasksDistance","text":""},{"location":"api/distance.html#themap.distance.base.AbstractTasksDistance","title":"themap.distance.base.AbstractTasksDistance","text":"<p>Base class for computing distances between tasks.</p> <p>This abstract class defines the interface for task distance computation. It distinguishes between: - Dataset distances: Between sets of molecules (OTDD, set-based Euclidean/Cosine) - Metadata distances: Between single vectors per task (vector-based Euclidean/Cosine)</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>Optional[Tasks]</code> <p>Tasks collection for distance computation</p> <code>None</code> <code>dataset_method</code> <code>str</code> <p>Distance computation method for datasets (molecules) (default: \"euclidean\")</p> <code>'euclidean'</code> <code>metadata_method</code> <code>str</code> <p>Distance computation method for metadata including protein (default: \"euclidean\")</p> <code>'euclidean'</code> <code>molecule_method</code> <code>Optional[str]</code> <p>Deprecated alias for dataset_method</p> <code>None</code> <code>protein_method</code> <code>Optional[str]</code> <p>Deprecated - protein is metadata, use metadata_method</p> <code>None</code> <code>method</code> <code>Optional[str]</code> <p>Global method (for backward compatibility, overrides individual methods if provided)</p> <code>None</code>"},{"location":"api/distance.html#themap.distance.base.AbstractTasksDistance.get_num_tasks","title":"get_num_tasks","text":"<pre><code>get_num_tasks() -&gt; Tuple[int, int]\n</code></pre> <p>Get the number of source and target tasks.</p>"},{"location":"api/distance.html#themap.distance.base.AbstractTasksDistance.get_distance","title":"get_distance","text":"<pre><code>get_distance() -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Compute the distance between datasets.</p> <p>Each of the subclasses should implement this method.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, float]]</code> <p>Dictionary containing distance matrix between source and target datasets.</p> <code>Dict[str, Dict[str, float]]</code> <p>The outer dictionary is keyed by target task IDs, and the inner dictionary</p> <code>Dict[str, Dict[str, float]]</code> <p>is keyed by source task IDs with distance values.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by subclass</p>"},{"location":"api/distance.html#themap.distance.base.AbstractTasksDistance.get_hopts","title":"get_hopts","text":"<pre><code>get_hopts(data_type: str = 'dataset') -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Get hyperparameters for distance computation.</p> <p>Each of the subclasses should implement this method.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>Type of data (\"dataset\", \"metadata\")       Legacy: \"molecule\" (alias for \"dataset\"), \"protein\" (alias for \"metadata\")</p> <code>'dataset'</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Dictionary containing hyperparameters for the distance computation method</p> <code>Optional[Dict[str, Any]]</code> <p>or None if no hyperparameters are needed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by subclass</p>"},{"location":"api/distance.html#themap.distance.base.AbstractTasksDistance.get_supported_methods","title":"get_supported_methods","text":"<pre><code>get_supported_methods(data_type: str) -&gt; List[str]\n</code></pre> <p>Get list of supported methods for a specific data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>Type of data (\"dataset\", \"metadata\")       Legacy: \"molecule\" (alias for \"dataset\"), \"protein\" (alias for \"metadata\")</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of supported method names for the data type</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by subclass</p>"},{"location":"api/distance.html#themap.distance.base.AbstractTasksDistance.__call__","title":"__call__","text":"<pre><code>__call__(*args: Any, **kwds: Any) -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Allow the class to be called as a function.</p> <p>Each of the subclasses should implement this method.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, float]]</code> <p>The computed distance matrix.</p>"},{"location":"api/distance.html#moleculedatasetdistance","title":"MoleculeDatasetDistance","text":""},{"location":"api/distance.html#themap.distance.molecule_distance.MoleculeDatasetDistance","title":"themap.distance.molecule_distance.MoleculeDatasetDistance","text":"<p>               Bases: <code>AbstractTasksDistance</code></p> <p>Calculate distances between molecule datasets using various methods.</p> <p>This class implements distance computation between molecule datasets using: - Optimal Transport Dataset Distance (OTDD) - Euclidean distance - Cosine distance</p> <p>The class supports both single dataset comparisons and batch comparisons across multiple datasets.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>Optional[Tasks]</code> <p>Tasks collection containing molecule datasets for distance computation</p> <code>None</code> <code>method</code> <code>Optional[str]</code> <p>Distance computation method ('otdd', 'euclidean', or 'cosine')</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the distance computation method</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified method is not supported for molecule datasets</p>"},{"location":"api/distance.html#themap.distance.molecule_distance.MoleculeDatasetDistance.get_hopts","title":"get_hopts","text":"<pre><code>get_hopts(data_type: str = 'molecule') -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Get hyperparameters for the distance computation method.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>Type of data (\"molecule\", \"protein\", \"metadata\")</p> <code>'molecule'</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Dictionary of hyperparameters specific to the chosen distance method for the data type.</p>"},{"location":"api/distance.html#themap.distance.molecule_distance.MoleculeDatasetDistance.get_supported_methods","title":"get_supported_methods","text":"<pre><code>get_supported_methods(data_type: str) -&gt; List[str]\n</code></pre> <p>Get list of supported methods for a specific data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>Type of data (\"molecule\", \"protein\", \"metadata\")</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of supported method names for the data type</p>"},{"location":"api/distance.html#themap.distance.molecule_distance.MoleculeDatasetDistance.otdd_distance","title":"otdd_distance","text":"<pre><code>otdd_distance() -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Compute Optimal Transport Dataset Distance between molecule datasets.</p> <p>This method uses the OTDD implementation to compute distances between molecule datasets, which takes into account both the feature space and label space of the datasets.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, float]]</code> <p>Dictionary containing OTDD distances between source and target datasets.</p> <code>Dict[str, Dict[str, float]]</code> <p>The outer dictionary is keyed by target task IDs, and the inner dictionary</p> <code>Dict[str, Dict[str, float]]</code> <p>is keyed by source task IDs with distance values.</p>"},{"location":"api/distance.html#themap.distance.molecule_distance.MoleculeDatasetDistance.euclidean_distance","title":"euclidean_distance","text":"<pre><code>euclidean_distance(\n    featurizer_name: str = \"ecfp\",\n) -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Compute Euclidean distance between molecule datasets.</p> <p>This method computes the dataset-level Euclidean distance by comparing the prototypes of the datasets.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>str</code> <p>Name of the molecular featurizer to use (e.g., \"ecfp\", \"maccs\", \"desc2D\")</p> <code>'ecfp'</code> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, float]]</code> <p>Dictionary containing Euclidean distances between source and target datasets.</p> <code>Dict[str, Dict[str, float]]</code> <p>The outer dictionary is keyed by target task IDs, and the inner dictionary</p> <code>Dict[str, Dict[str, float]]</code> <p>is keyed by source task IDs with distance values.</p> <p>Raises:</p> Type Description <code>DistanceComputationError</code> <p>If feature computation fails</p>"},{"location":"api/distance.html#themap.distance.molecule_distance.MoleculeDatasetDistance.cosine_distance","title":"cosine_distance","text":"<pre><code>cosine_distance(featurizer_name: str = 'ecfp') -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Compute cosine distance between molecule datasets.</p> <p>This method computes the dataset-level cosine distance by comparing the prototypes of the datasets.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>str</code> <p>Name of the molecular featurizer to use (e.g., \"ecfp\", \"maccs\", \"desc2D\")</p> <code>'ecfp'</code> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, float]]</code> <p>Dictionary containing cosine distances between source and target datasets.</p> <code>Dict[str, Dict[str, float]]</code> <p>The outer dictionary is keyed by target task IDs, and the inner dictionary</p> <code>Dict[str, Dict[str, float]]</code> <p>is keyed by source task IDs with distance values.</p>"},{"location":"api/distance.html#themap.distance.molecule_distance.MoleculeDatasetDistance.get_distance","title":"get_distance","text":"<pre><code>get_distance(featurizer_name: str = 'ecfp') -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Compute the distance between molecule datasets using the specified method.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>str</code> <p>Name of the molecular featurizer to use (e.g., \"ecfp\", \"maccs\", \"desc2D\")</p> <code>'ecfp'</code> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, float]]</code> <p>Dictionary containing distance matrix between source and target datasets.</p> <code>Dict[str, Dict[str, float]]</code> <p>The outer dictionary is keyed by target task IDs, and the inner dictionary</p> <code>Dict[str, Dict[str, float]]</code> <p>is keyed by source task IDs with distance values.</p>"},{"location":"api/distance.html#themap.distance.molecule_distance.MoleculeDatasetDistance.load_distance","title":"load_distance","text":"<pre><code>load_distance(path: str) -&gt; None\n</code></pre> <p>Load pre-computed distances from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file containing pre-computed distances</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>ValueError</code> <p>If the file format is invalid</p>"},{"location":"api/distance.html#themap.distance.molecule_distance.MoleculeDatasetDistance.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas() -&gt; pd.DataFrame\n</code></pre> <p>Convert the distance matrix to a pandas DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with source task IDs as index and target task IDs as columns,</p> <code>DataFrame</code> <p>containing the distance values.</p>"},{"location":"api/distance.html#themap.distance.molecule_distance.MoleculeDatasetDistance.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of the MoleculeDatasetDistance instance.</p> <p>Returns:</p> Type Description <code>str</code> <p>String containing the class name and initialization parameters.</p>"},{"location":"api/distance.html#proteindatasetdistance","title":"ProteinDatasetDistance","text":""},{"location":"api/distance.html#themap.distance.protein_distance.ProteinDatasetDistance","title":"themap.distance.protein_distance.ProteinDatasetDistance","text":"<p>               Bases: <code>AbstractTasksDistance</code></p> <p>Calculate distances between protein datasets using various methods.</p> <p>This class implements distance computation between protein datasets using: - Euclidean distance - Cosine distance</p> <p>The class supports both single dataset comparisons and batch comparisons across multiple datasets.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>Optional[Tasks]</code> <p>Tasks collection containing protein datasets for distance computation</p> <code>None</code> <code>method</code> <code>Optional[str]</code> <p>Distance computation method ('euclidean' or 'cosine')</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified method is not supported for protein datasets</p>"},{"location":"api/distance.html#themap.distance.protein_distance.ProteinDatasetDistance.get_hopts","title":"get_hopts","text":"<pre><code>get_hopts(data_type: str = 'protein') -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Get hyperparameters for the distance computation method.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>Type of data (\"molecule\", \"protein\", \"metadata\")</p> <code>'protein'</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Dictionary of hyperparameters specific to the chosen distance method for the data type.</p>"},{"location":"api/distance.html#themap.distance.protein_distance.ProteinDatasetDistance.get_supported_methods","title":"get_supported_methods","text":"<pre><code>get_supported_methods(data_type: str) -&gt; List[str]\n</code></pre> <p>Get list of supported methods for a specific data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>Type of data (\"molecule\", \"protein\", \"metadata\")</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of supported method names for the data type</p>"},{"location":"api/distance.html#themap.distance.protein_distance.ProteinDatasetDistance.euclidean_distance","title":"euclidean_distance","text":"<pre><code>euclidean_distance() -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Compute Euclidean distance between protein datasets.</p> <p>This method calculates the pairwise Euclidean distances between protein feature vectors in the datasets.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, float]]</code> <p>Dictionary containing Euclidean distances between source and target datasets.</p> <code>Dict[str, Dict[str, float]]</code> <p>The outer dictionary is keyed by target task IDs, and the inner dictionary</p> <code>Dict[str, Dict[str, float]]</code> <p>is keyed by source task IDs with distance values.</p>"},{"location":"api/distance.html#themap.distance.protein_distance.ProteinDatasetDistance.cosine_distance","title":"cosine_distance","text":"<pre><code>cosine_distance() -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Compute cosine distance between protein datasets.</p> <p>This method calculates the pairwise cosine distances between protein feature vectors in the datasets.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, float]]</code> <p>Dictionary containing cosine distances between source and target datasets.</p> <code>Dict[str, Dict[str, float]]</code> <p>The outer dictionary is keyed by target task IDs, and the inner dictionary</p> <code>Dict[str, Dict[str, float]]</code> <p>is keyed by source task IDs with distance values.</p>"},{"location":"api/distance.html#themap.distance.protein_distance.ProteinDatasetDistance.sequence_identity_distance","title":"sequence_identity_distance","text":"<pre><code>sequence_identity_distance() -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Compute sequence identity-based distance between protein datasets.</p> <p>This method calculates distances based on protein sequence identity.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, float]]</code> <p>Dictionary containing sequence identity-based distances between datasets.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method is not yet implemented</p>"},{"location":"api/distance.html#themap.distance.protein_distance.ProteinDatasetDistance.get_distance","title":"get_distance","text":"<pre><code>get_distance() -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Compute the distance between protein datasets using the specified method.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, float]]</code> <p>Dictionary containing distance matrix between source and target datasets.</p> <code>Dict[str, Dict[str, float]]</code> <p>The outer dictionary is keyed by target task IDs, and the inner dictionary</p> <code>Dict[str, Dict[str, float]]</code> <p>is keyed by source task IDs with distance values.</p>"},{"location":"api/distance.html#themap.distance.protein_distance.ProteinDatasetDistance.load_distance","title":"load_distance","text":"<pre><code>load_distance(path: str) -&gt; None\n</code></pre> <p>Load pre-computed distances from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file containing pre-computed distances</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>ValueError</code> <p>If the file format is invalid</p>"},{"location":"api/distance.html#themap.distance.protein_distance.ProteinDatasetDistance.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas() -&gt; pd.DataFrame\n</code></pre> <p>Convert the distance matrix to a pandas DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with source task IDs as index and target task IDs as columns,</p> <code>DataFrame</code> <p>containing the distance values.</p>"},{"location":"api/distance.html#themap.distance.protein_distance.ProteinDatasetDistance.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of the ProteinDatasetDistance instance.</p> <p>Returns:</p> Type Description <code>str</code> <p>String containing the class name and initialization parameters.</p>"},{"location":"api/distance.html#taskdistance","title":"TaskDistance","text":""},{"location":"api/distance.html#themap.distance.task_distance.TaskDistance","title":"themap.distance.task_distance.TaskDistance  <code>module-attribute</code>","text":"<pre><code>TaskDistance = TaskDistanceCalculator\n</code></pre>"},{"location":"api/distance.html#utility-functions","title":"Utility Functions","text":""},{"location":"api/distance.html#validation-functions","title":"Validation Functions","text":""},{"location":"api/distance.html#themap.distance.base._validate_and_extract_task_id","title":"themap.distance.base._validate_and_extract_task_id","text":"<pre><code>_validate_and_extract_task_id(task_name: str) -&gt; str\n</code></pre> <p>Safely extract task ID from task name with validation.</p> <p>Parameters:</p> Name Type Description Default <code>task_name</code> <code>str</code> <p>Task name in format 'fold_task_id'</p> required <p>Returns:</p> Type Description <code>str</code> <p>Extracted task ID</p> <p>Raises:</p> Type Description <code>DataValidationError</code> <p>If task name format is invalid</p>"},{"location":"api/distance.html#exception-classes","title":"Exception Classes","text":""},{"location":"api/distance.html#distancecomputationerror","title":"DistanceComputationError","text":""},{"location":"api/distance.html#themap.distance.exceptions.DistanceComputationError","title":"themap.distance.exceptions.DistanceComputationError","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for distance computation errors.</p>"},{"location":"api/distance.html#datavalidationerror","title":"DataValidationError","text":""},{"location":"api/distance.html#themap.distance.exceptions.DataValidationError","title":"themap.distance.exceptions.DataValidationError","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for data validation errors.</p>"},{"location":"api/distance.html#constants","title":"Constants","text":""},{"location":"api/distance.html#supported-methods","title":"Supported Methods","text":"<pre><code># Available distance methods for molecule datasets\nMOLECULE_DISTANCE_METHODS = [\"otdd\", \"euclidean\", \"cosine\"]\n\n# Available distance methods for protein datasets\nPROTEIN_DISTANCE_METHODS = [\"euclidean\", \"cosine\"]\n</code></pre>"},{"location":"api/distance.html#usage-examples","title":"Usage Examples","text":""},{"location":"api/distance.html#basic-molecule-distance-computation","title":"Basic Molecule Distance Computation","text":"<pre><code>from themap.data.tasks import Tasks\nfrom themap.distance import MoleculeDatasetDistance\n\n# Load tasks from directory\ntasks = Tasks.from_directory(\n    directory=\"datasets/\",\n    task_list_file=\"datasets/sample_tasks_list.json\",\n    load_molecules=True,\n    load_proteins=False\n)\n\n# Compute molecule distances using OTDD\nmol_distance = MoleculeDatasetDistance(\n    tasks=tasks,\n    molecule_method=\"otdd\"\n)\n\ndistances = mol_distance.get_distance()\nprint(distances)\n# {'target_task': {'source_task': 0.75, ...}}\n</code></pre>"},{"location":"api/distance.html#protein-distance-computation","title":"Protein Distance Computation","text":"<pre><code>from themap.distance import ProteinDatasetDistance\n\n# Compute protein distances using euclidean method\nprot_distance = ProteinDatasetDistance(\n    tasks=tasks,\n    protein_method=\"euclidean\"\n)\n\ndistances = prot_distance.get_distance()\n</code></pre>"},{"location":"api/distance.html#combined-task-distance","title":"Combined Task Distance","text":"<pre><code>from themap.distance import TaskDistance\n\n# Compute combined distances from multiple modalities\ntask_distance = TaskDistance(\n    tasks=tasks,\n    molecule_method=\"cosine\",\n    protein_method=\"euclidean\"\n)\n\n# Compute all distance types\nall_distances = task_distance.compute_all_distances(\n    combination_strategy=\"weighted_average\",\n    molecule_weight=0.7,\n    protein_weight=0.3\n)\n\n# Access specific distance types\nmolecule_distances = all_distances[\"molecule\"]\nprotein_distances = all_distances[\"protein\"]\ncombined_distances = all_distances[\"combined\"]\n</code></pre>"},{"location":"api/distance.html#working-with-external-distance-matrices","title":"Working with External Distance Matrices","text":"<pre><code>import numpy as np\n\n# Load pre-computed distances\ntask_distance = TaskDistance.load_ext_chem_distance(\"path/to/chemical_distances.pkl\")\n\n# Or initialize with external matrices\nexternal_chem = np.random.rand(10, 8)  # 10 source, 8 target tasks\ntask_distance = TaskDistance(\n    tasks=None,\n    source_task_ids=[\"task1\", \"task2\", ...],\n    target_task_ids=[\"test1\", \"test2\", ...],\n    external_chemical_space=external_chem\n)\n\n# Convert to pandas for analysis\ndf = task_distance.to_pandas(\"external_chemical\")\n</code></pre>"},{"location":"api/distance.html#error-handling","title":"Error Handling","text":"<pre><code>from themap.distance import DistanceComputationError, DataValidationError\n\ntry:\n    # This might fail if OTDD dependencies are missing\n    distances = mol_distance.otdd_distance()\nexcept ImportError as e:\n    print(f\"OTDD not available: {e}\")\n    # Fall back to euclidean distance\n    distances = mol_distance.euclidean_distance()\nexcept DistanceComputationError as e:\n    print(f\"Distance computation failed: {e}\")\nexcept DataValidationError as e:\n    print(f\"Data validation failed: {e}\")\n</code></pre>"},{"location":"api/distance.html#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/distance.html#memory-usage","title":"Memory Usage","text":"<ul> <li>OTDD: Most memory-intensive, especially for large datasets</li> <li>Euclidean/Cosine: More memory-efficient, suitable for large-scale computations</li> <li>External matrices: Memory usage depends on matrix size</li> </ul>"},{"location":"api/distance.html#computational-complexity","title":"Computational Complexity","text":"<ul> <li>OTDD: O(n\u00b2m\u00b2) where n,m are dataset sizes</li> <li>Euclidean/Cosine: O(nm) for feature extraction + O(kl) for distance matrix where k,l are number of tasks</li> <li>Combined distances: Sum of individual method complexities</li> </ul>"},{"location":"api/distance.html#optimization-tips","title":"Optimization Tips","text":"<pre><code># 1. Use appropriate max_samples for OTDD\nhopts = {\"maxsamples\": 500}  # Reduce for faster computation\n\n# 2. Cache features for repeated computations\ntasks.save_task_features_to_file(\"cached_features.pkl\")\ncached_features = Tasks.load_task_features_from_file(\"cached_features.pkl\")\n\n# 3. Use appropriate distance method based on data size\nif num_molecules &gt; 10000:\n    method = \"euclidean\"  # Faster for large datasets\nelse:\n    method = \"otdd\"       # More accurate for smaller datasets\n</code></pre>"},{"location":"api/distance.html#configuration","title":"Configuration","text":""},{"location":"api/distance.html#distance-method-configuration","title":"Distance Method Configuration","text":"<p>Configuration files for distance methods are stored in <code>themap/models/distance_configures/</code>:</p> <pre><code>// otdd.json\n{\n    \"method\": \"otdd\",\n    \"maxsamples\": 1000,\n    \"device\": \"auto\",\n    \"parallel\": true\n}\n</code></pre>"},{"location":"api/distance.html#custom-configuration","title":"Custom Configuration","text":"<pre><code>from themap.utils.distance_utils import get_configure\n\n# Get default configuration\nconfig = get_configure(\"otdd\")\n\n# Modify configuration\nconfig[\"maxsamples\"] = 500\nconfig[\"device\"] = \"cpu\"\n\n# Use in distance computation\nmol_distance = MoleculeDatasetDistance(tasks=tasks, molecule_method=\"otdd\")\n# Configuration is automatically loaded and can be overridden\n</code></pre>"},{"location":"api/features.html","title":"Features Module","text":"<p>The features module provides unified feature extraction for molecules and proteins. It handles featurization, caching, and batch processing.</p>"},{"location":"api/features.html#overview","title":"Overview","text":"<p>The features system consists of three main components:</p> <ul> <li><code>MoleculeFeaturizer</code> - Extract molecular representations (fingerprints, descriptors, embeddings)</li> <li><code>ProteinFeaturizer</code> - Extract protein sequence embeddings (ESM2, ESM3)</li> <li><code>FeatureCache</code> - Efficient caching for expensive feature computations</li> </ul>"},{"location":"api/features.html#molecule-featurizer","title":"Molecule Featurizer","text":""},{"location":"api/features.html#moleculefeaturizer","title":"MoleculeFeaturizer","text":""},{"location":"api/features.html#themap.features.molecule.MoleculeFeaturizer","title":"themap.features.molecule.MoleculeFeaturizer","text":"<p>Efficient molecule featurization using molfeat.</p> <p>Provides batch featurization with SMILES deduplication for efficiency. Supports fingerprints, descriptors, and neural embeddings.</p> <p>Attributes:</p> Name Type Description <code>featurizer_name</code> <p>Name of the featurizer to use.</p> <code>n_jobs</code> <p>Number of parallel workers for featurization.</p> <code>_transformer</code> <p>Cached molfeat transformer instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; featurizer = MoleculeFeaturizer(\"ecfp\")\n&gt;&gt;&gt; features = featurizer.featurize([\"CCO\", \"CCCO\", \"CCCCO\"])\n&gt;&gt;&gt; print(features.shape)  # (3, 2048)\n</code></pre> <pre><code>&gt;&gt;&gt; # With SMILES deduplication\n&gt;&gt;&gt; smiles = [\"CCO\", \"CCCO\", \"CCO\", \"CCCCO\", \"CCCO\"]\n&gt;&gt;&gt; features = featurizer.featurize_deduplicated(smiles)\n&gt;&gt;&gt; print(features.shape)  # (5, 2048) - returns features for all input SMILES\n</code></pre>"},{"location":"api/features.html#themap.features.molecule.MoleculeFeaturizer.transformer","title":"transformer  <code>property</code>","text":"<pre><code>transformer\n</code></pre> <p>Get or create the molfeat transformer (lazy initialization).</p>"},{"location":"api/features.html#themap.features.molecule.MoleculeFeaturizer.is_fingerprint","title":"is_fingerprint  <code>property</code>","text":"<pre><code>is_fingerprint: bool\n</code></pre> <p>Check if this is a fingerprint-based featurizer.</p>"},{"location":"api/features.html#themap.features.molecule.MoleculeFeaturizer.is_neural","title":"is_neural  <code>property</code>","text":"<pre><code>is_neural: bool\n</code></pre> <p>Check if this is a neural embedding featurizer.</p>"},{"location":"api/features.html#themap.features.molecule.MoleculeFeaturizer.__init__","title":"__init__","text":"<pre><code>__init__(featurizer_name: str = 'ecfp', n_jobs: int = 8, device: str = 'auto')\n</code></pre> <p>Initialize the molecule featurizer.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>str</code> <p>Name of the molfeat featurizer to use.</p> <code>'ecfp'</code> <code>n_jobs</code> <code>int</code> <p>Number of parallel workers for featurization.</p> <code>8</code> <code>device</code> <code>str</code> <p>Device for neural featurizers ('auto', 'cpu', 'cuda').</p> <code>'auto'</code>"},{"location":"api/features.html#themap.features.molecule.MoleculeFeaturizer.featurize","title":"featurize","text":"<pre><code>featurize(\n    smiles: Union[str, List[str]], ignore_errors: bool = True\n) -&gt; NDArray[np.float32]\n</code></pre> <p>Featurize one or more SMILES strings.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>Union[str, List[str]]</code> <p>Single SMILES string or list of SMILES.</p> required <code>ignore_errors</code> <code>bool</code> <p>If True, return NaN for invalid SMILES.</p> <code>True</code> <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Feature array of shape (n_molecules, feature_dim).</p>"},{"location":"api/features.html#themap.features.molecule.MoleculeFeaturizer.featurize_deduplicated","title":"featurize_deduplicated","text":"<pre><code>featurize_deduplicated(\n    smiles: List[str], ignore_errors: bool = True\n) -&gt; NDArray[np.float32]\n</code></pre> <p>Featurize SMILES with deduplication for efficiency.</p> <p>Unique SMILES are featurized once, then results are mapped back to the original list. This is efficient when there are many duplicate SMILES across datasets.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>List[str]</code> <p>List of SMILES strings (may contain duplicates).</p> required <code>ignore_errors</code> <code>bool</code> <p>If True, return NaN for invalid SMILES.</p> <code>True</code> <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Feature array of shape (n_molecules, feature_dim) in original order.</p>"},{"location":"api/features.html#themap.features.molecule.MoleculeFeaturizer.featurize_datasets","title":"featurize_datasets","text":"<pre><code>featurize_datasets(\n    datasets: Dict[str, MoleculeDataset], deduplicate: bool = True\n) -&gt; Dict[str, NDArray[np.float32]]\n</code></pre> <p>Featurize multiple datasets efficiently.</p> <p>When deduplicate=True, collects all unique SMILES across all datasets, featurizes them once, then maps back to each dataset.</p> <p>Parameters:</p> Name Type Description Default <code>datasets</code> <code>Dict[str, MoleculeDataset]</code> <p>Dictionary mapping task IDs to MoleculeDataset instances.</p> required <code>deduplicate</code> <code>bool</code> <p>If True, deduplicate SMILES across all datasets.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, NDArray[float32]]</code> <p>Dictionary mapping task IDs to feature arrays.</p>"},{"location":"api/features.html#themap.features.molecule.MoleculeFeaturizer.get_feature_dim","title":"get_feature_dim","text":"<pre><code>get_feature_dim() -&gt; int\n</code></pre> <p>Get the feature dimension for this featurizer.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of features produced by this featurizer.</p>"},{"location":"api/features.html#available-featurizers","title":"Available Featurizers","text":""},{"location":"api/features.html#fingerprints-fast","title":"Fingerprints (Fast)","text":"Featurizer Description Dimensions <code>ecfp</code> Extended Connectivity Fingerprints 2048 <code>maccs</code> MACCS Structural Keys 167 <code>topological</code> Topological Fingerprints 2048 <code>avalon</code> Avalon Fingerprints 512"},{"location":"api/features.html#descriptors-medium-speed","title":"Descriptors (Medium Speed)","text":"Featurizer Description Dimensions <code>desc2D</code> 2D Molecular Descriptors ~200 <code>mordred</code> Mordred Descriptors ~1600"},{"location":"api/features.html#neural-embeddings-slow-gpu-recommended","title":"Neural Embeddings (Slow, GPU Recommended)","text":"Featurizer Description Dimensions <code>ChemBERTa-77M-MLM</code> ChemBERTa masked language model 384 <code>ChemBERTa-77M-MTR</code> ChemBERTa multi-task regression 384 <code>MolT5</code> Molecular T5 embeddings 768 <code>Roberta-Zinc480M-102M</code> RoBERTa trained on ZINC 768 <code>gin_supervised_*</code> Graph neural network embeddings 300"},{"location":"api/features.html#usage-examples","title":"Usage Examples","text":"<pre><code>from themap.features import MoleculeFeaturizer\n\n# Initialize featurizer\nfeaturizer = MoleculeFeaturizer(\n    featurizer_name=\"ecfp\",\n    n_jobs=8\n)\n\n# Featurize a list of SMILES\nsmiles_list = [\"CCO\", \"CCCO\", \"CC(=O)O\"]\nfeatures = featurizer.featurize(smiles_list)\n\nprint(f\"Features shape: {features.shape}\")\n# Features shape: (3, 2048)\n</code></pre>"},{"location":"api/features.html#batch-processing-with-deduplication","title":"Batch Processing with Deduplication","text":"<pre><code>from themap.features import MoleculeFeaturizer\n\nfeaturizer = MoleculeFeaturizer(featurizer_name=\"ecfp\")\n\n# Featurize multiple datasets with global deduplication\ndatasets = {\n    \"task1\": dataset1,  # MoleculeDataset objects\n    \"task2\": dataset2,\n}\n\nfeatures = featurizer.featurize_datasets(\n    datasets,\n    deduplicate=True  # Avoid re-computing for duplicate SMILES\n)\n\nfor task_id, task_features in features.items():\n    print(f\"{task_id}: {task_features.shape}\")\n</code></pre>"},{"location":"api/features.html#protein-featurizer","title":"Protein Featurizer","text":""},{"location":"api/features.html#proteinfeaturizer","title":"ProteinFeaturizer","text":""},{"location":"api/features.html#themap.features.protein.ProteinFeaturizer","title":"themap.features.protein.ProteinFeaturizer","text":"<p>Efficient protein featurization using ESM models.</p> <p>Provides batch featurization of protein sequences using ESM2 or ESM3 models. Models are cached globally to avoid reloading.</p> <p>Attributes:</p> Name Type Description <code>featurizer_name</code> <p>Name of the ESM model to use.</p> <code>layer</code> <p>Which transformer layer to extract embeddings from.</p> <code>device</code> <p>Device for computation ('auto', 'cpu', 'cuda').</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; featurizer = ProteinFeaturizer(\"esm2_t33_650M_UR50D\")\n&gt;&gt;&gt; sequences = {\"P1\": \"MKTVRQ...\", \"P2\": \"MENLNM...\"}\n&gt;&gt;&gt; features = featurizer.featurize(sequences)\n&gt;&gt;&gt; print(features.shape)  # (2, 1280)\n</code></pre>"},{"location":"api/features.html#themap.features.protein.ProteinFeaturizer.is_esm2","title":"is_esm2  <code>property</code>","text":"<pre><code>is_esm2: bool\n</code></pre> <p>Check if this is an ESM2 model.</p>"},{"location":"api/features.html#themap.features.protein.ProteinFeaturizer.is_esm3","title":"is_esm3  <code>property</code>","text":"<pre><code>is_esm3: bool\n</code></pre> <p>Check if this is an ESM3 model.</p>"},{"location":"api/features.html#themap.features.protein.ProteinFeaturizer.__init__","title":"__init__","text":"<pre><code>__init__(\n    featurizer_name: str = \"esm2_t33_650M_UR50D\",\n    layer: Optional[int] = None,\n    device: str = \"auto\",\n)\n</code></pre> <p>Initialize the protein featurizer.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer_name</code> <code>str</code> <p>Name of the ESM model to use.</p> <code>'esm2_t33_650M_UR50D'</code> <code>layer</code> <code>Optional[int]</code> <p>Which transformer layer to extract embeddings from.    If None, uses the default for the model.</p> <code>None</code> <code>device</code> <code>str</code> <p>Device for computation ('auto', 'cpu', 'cuda').</p> <code>'auto'</code>"},{"location":"api/features.html#themap.features.protein.ProteinFeaturizer.featurize","title":"featurize","text":"<pre><code>featurize(sequences: Union[Dict[str, str], List[str]]) -&gt; NDArray[np.float32]\n</code></pre> <p>Featurize protein sequences.</p> <p>Parameters:</p> Name Type Description Default <code>sequences</code> <code>Union[Dict[str, str], List[str]]</code> <p>Either a dictionary mapping protein IDs to sequences,       or a list of sequences.</p> required <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Feature array of shape (n_proteins, embedding_dim).</p>"},{"location":"api/features.html#themap.features.protein.ProteinFeaturizer.featurize_from_fasta","title":"featurize_from_fasta","text":"<pre><code>featurize_from_fasta(\n    fasta_path: Union[str, Path],\n) -&gt; Dict[str, NDArray[np.float32]]\n</code></pre> <p>Featurize proteins from a FASTA file.</p> <p>Parameters:</p> Name Type Description Default <code>fasta_path</code> <code>Union[str, Path]</code> <p>Path to the FASTA file.</p> required <p>Returns:</p> Type Description <code>Dict[str, NDArray[float32]]</code> <p>Dictionary mapping protein IDs to feature vectors.</p>"},{"location":"api/features.html#themap.features.protein.ProteinFeaturizer.featurize_directory","title":"featurize_directory","text":"<pre><code>featurize_directory(\n    directory: Union[str, Path], pattern: str = \"*.fasta\"\n) -&gt; Dict[str, NDArray[np.float32]]\n</code></pre> <p>Featurize all proteins from FASTA files in a directory.</p> <p>Each FASTA file is expected to contain one protein sequence. The filename (without extension) is used as the task/protein ID.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Union[str, Path]</code> <p>Path to directory containing FASTA files.</p> required <code>pattern</code> <code>str</code> <p>Glob pattern for finding FASTA files.</p> <code>'*.fasta'</code> <p>Returns:</p> Type Description <code>Dict[str, NDArray[float32]]</code> <p>Dictionary mapping task IDs to feature vectors.</p>"},{"location":"api/features.html#themap.features.protein.ProteinFeaturizer.get_feature_dim","title":"get_feature_dim","text":"<pre><code>get_feature_dim() -&gt; int\n</code></pre> <p>Get the feature dimension for this featurizer.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of features produced by this featurizer.</p>"},{"location":"api/features.html#available-models","title":"Available Models","text":""},{"location":"api/features.html#esm2-models","title":"ESM2 Models","text":"Model Parameters Layers Embedding Dim <code>esm2_t6_8M_UR50D</code> 8M 6 320 <code>esm2_t12_35M_UR50D</code> 35M 12 480 <code>esm2_t30_150M_UR50D</code> 150M 30 640 <code>esm2_t33_650M_UR50D</code> 650M 33 1280"},{"location":"api/features.html#esm3-models","title":"ESM3 Models","text":"Model Description <code>esm3_sm_open_v1</code> ESM3 small open model"},{"location":"api/features.html#usage-examples_1","title":"Usage Examples","text":"<pre><code>from themap.features import ProteinFeaturizer\n\n# Initialize with ESM2\nfeaturizer = ProteinFeaturizer(\n    model_name=\"esm2_t33_650M_UR50D\",\n    device=\"cuda\"  # Use GPU if available\n)\n\n# Featurize protein sequences\nsequences = [\n    \"MKTVRQERLKSIVRILERSKEPVSG\",\n    \"MGSSHHHHHHSSGLVPRGSHM\"\n]\n\nembeddings = featurizer.featurize(sequences)\nprint(f\"Embeddings shape: {embeddings.shape}\")\n# Embeddings shape: (2, 1280)\n</code></pre>"},{"location":"api/features.html#reading-from-fasta-files","title":"Reading from FASTA Files","text":"<pre><code>from themap.features.protein import read_fasta_file\n\n# Read sequences from FASTA\nsequences = read_fasta_file(\"proteins.fasta\")\n\nfor seq_id, sequence in sequences.items():\n    print(f\"{seq_id}: {len(sequence)} residues\")\n</code></pre>"},{"location":"api/features.html#feature-cache","title":"Feature Cache","text":""},{"location":"api/features.html#featurecache","title":"FeatureCache","text":""},{"location":"api/features.html#themap.features.cache.FeatureCache","title":"themap.features.cache.FeatureCache","text":"<p>Disk-based feature caching for molecules and proteins.</p> <p>Caches computed features to NPZ/NPY files for efficient reuse across runs. Supports both molecule features (per-dataset with labels) and protein features (single vector per task).</p> <p>Attributes:</p> Name Type Description <code>cache_dir</code> <p>Root directory for cached features.</p> <code>molecule_dir</code> <p>Directory for molecule features.</p> <code>protein_dir</code> <p>Directory for protein features.</p> Directory Structure <p>cache_dir/ \u251c\u2500\u2500 molecule/ \u2502   \u2514\u2500\u2500 {featurizer}/ \u2502       \u2514\u2500\u2500 {task_id}.npz  # features + labels \u2514\u2500\u2500 protein/     \u2514\u2500\u2500 {featurizer}/         \u2514\u2500\u2500 {task_id}.npy  # single vector</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cache = FeatureCache(\"./feature_cache\")\n&gt;&gt;&gt; # Save molecule features\n&gt;&gt;&gt; cache.save_molecule_features(\"CHEMBL123\", \"ecfp\", features, labels)\n&gt;&gt;&gt; # Load if exists\n&gt;&gt;&gt; features, labels = cache.load_molecule_features(\"CHEMBL123\", \"ecfp\")\n&gt;&gt;&gt; if features is None:\n...     # Compute and save\n...     cache.save_molecule_features(\"CHEMBL123\", \"ecfp\", features, labels)\n</code></pre>"},{"location":"api/features.html#themap.features.cache.FeatureCache.__init__","title":"__init__","text":"<pre><code>__init__(cache_dir: Union[str, Path])\n</code></pre> <p>Initialize the feature cache.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>Union[str, Path]</code> <p>Root directory for cached features.</p> required"},{"location":"api/features.html#themap.features.cache.FeatureCache.has_molecule_features","title":"has_molecule_features","text":"<pre><code>has_molecule_features(task_id: str, featurizer: str) -&gt; bool\n</code></pre> <p>Check if molecule features are cached.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>Task ID to check.</p> required <code>featurizer</code> <code>str</code> <p>Name of the featurizer.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if features are cached.</p>"},{"location":"api/features.html#themap.features.cache.FeatureCache.has_protein_features","title":"has_protein_features","text":"<pre><code>has_protein_features(task_id: str, featurizer: str) -&gt; bool\n</code></pre> <p>Check if protein features are cached.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>Task ID to check.</p> required <code>featurizer</code> <code>str</code> <p>Name of the featurizer.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if features are cached.</p>"},{"location":"api/features.html#themap.features.cache.FeatureCache.save_molecule_features","title":"save_molecule_features","text":"<pre><code>save_molecule_features(\n    task_id: str,\n    featurizer: str,\n    features: NDArray[float32],\n    labels: NDArray[int32],\n    metadata: Optional[Dict[str, Any]] = None,\n) -&gt; Path\n</code></pre> <p>Save molecule features to cache.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>Task ID for the dataset.</p> required <code>featurizer</code> <code>str</code> <p>Name of the featurizer used.</p> required <code>features</code> <code>NDArray[float32]</code> <p>Feature matrix of shape (n_molecules, feature_dim).</p> required <code>labels</code> <code>NDArray[int32]</code> <p>Binary labels of shape (n_molecules,).</p> required <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the saved file.</p>"},{"location":"api/features.html#themap.features.cache.FeatureCache.load_molecule_features","title":"load_molecule_features","text":"<pre><code>load_molecule_features(\n    task_id: str, featurizer: str\n) -&gt; Tuple[Optional[NDArray[np.float32]], Optional[NDArray[np.int32]]]\n</code></pre> <p>Load molecule features from cache.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>Task ID for the dataset.</p> required <code>featurizer</code> <code>str</code> <p>Name of the featurizer.</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[NDArray[float32]], Optional[NDArray[int32]]]</code> <p>Tuple of (features, labels), or (None, None) if not cached.</p>"},{"location":"api/features.html#themap.features.cache.FeatureCache.save_protein_features","title":"save_protein_features","text":"<pre><code>save_protein_features(\n    task_id: str, featurizer: str, features: NDArray[float32]\n) -&gt; Path\n</code></pre> <p>Save protein features to cache.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>Task ID for the protein.</p> required <code>featurizer</code> <code>str</code> <p>Name of the featurizer used.</p> required <code>features</code> <code>NDArray[float32]</code> <p>Feature vector of shape (feature_dim,).</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the saved file.</p>"},{"location":"api/features.html#themap.features.cache.FeatureCache.load_protein_features","title":"load_protein_features","text":"<pre><code>load_protein_features(\n    task_id: str, featurizer: str\n) -&gt; Optional[NDArray[np.float32]]\n</code></pre> <p>Load protein features from cache.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>Task ID for the protein.</p> required <code>featurizer</code> <code>str</code> <p>Name of the featurizer.</p> required <p>Returns:</p> Type Description <code>Optional[NDArray[float32]]</code> <p>Feature vector, or None if not cached.</p>"},{"location":"api/features.html#themap.features.cache.FeatureCache.save_all_molecule_features","title":"save_all_molecule_features","text":"<pre><code>save_all_molecule_features(\n    features_dict: Dict[str, NDArray[float32]],\n    labels_dict: Dict[str, NDArray[int32]],\n    featurizer: str,\n) -&gt; List[Path]\n</code></pre> <p>Save molecule features for multiple datasets.</p> <p>Parameters:</p> Name Type Description Default <code>features_dict</code> <code>Dict[str, NDArray[float32]]</code> <p>Dictionary mapping task IDs to feature matrices.</p> required <code>labels_dict</code> <code>Dict[str, NDArray[int32]]</code> <p>Dictionary mapping task IDs to label arrays.</p> required <code>featurizer</code> <code>str</code> <p>Name of the featurizer used.</p> required <p>Returns:</p> Type Description <code>List[Path]</code> <p>List of paths to saved files.</p>"},{"location":"api/features.html#themap.features.cache.FeatureCache.save_all_protein_features","title":"save_all_protein_features","text":"<pre><code>save_all_protein_features(\n    features_dict: Dict[str, NDArray[float32]], featurizer: str\n) -&gt; List[Path]\n</code></pre> <p>Save protein features for multiple tasks.</p> <p>Parameters:</p> Name Type Description Default <code>features_dict</code> <code>Dict[str, NDArray[float32]]</code> <p>Dictionary mapping task IDs to feature vectors.</p> required <code>featurizer</code> <code>str</code> <p>Name of the featurizer used.</p> required <p>Returns:</p> Type Description <code>List[Path]</code> <p>List of paths to saved files.</p>"},{"location":"api/features.html#themap.features.cache.FeatureCache.load_all_molecule_features","title":"load_all_molecule_features","text":"<pre><code>load_all_molecule_features(\n    task_ids: List[str], featurizer: str\n) -&gt; Tuple[\n    Dict[str, NDArray[np.float32]], Dict[str, NDArray[np.int32]], List[str]\n]\n</code></pre> <p>Load molecule features for multiple datasets.</p> <p>Parameters:</p> Name Type Description Default <code>task_ids</code> <code>List[str]</code> <p>List of task IDs to load.</p> required <code>featurizer</code> <code>str</code> <p>Name of the featurizer.</p> required <p>Returns:</p> Type Description <code>Dict[str, NDArray[float32]]</code> <p>Tuple of (features_dict, labels_dict, missing_ids).</p> <code>Dict[str, NDArray[int32]]</code> <p>missing_ids contains task IDs that were not found in cache.</p>"},{"location":"api/features.html#themap.features.cache.FeatureCache.load_all_protein_features","title":"load_all_protein_features","text":"<pre><code>load_all_protein_features(\n    task_ids: List[str], featurizer: str\n) -&gt; Tuple[Dict[str, NDArray[np.float32]], List[str]]\n</code></pre> <p>Load protein features for multiple tasks.</p> <p>Parameters:</p> Name Type Description Default <code>task_ids</code> <code>List[str]</code> <p>List of task IDs to load.</p> required <code>featurizer</code> <code>str</code> <p>Name of the featurizer.</p> required <p>Returns:</p> Type Description <code>Dict[str, NDArray[float32]]</code> <p>Tuple of (features_dict, missing_ids).</p> <code>List[str]</code> <p>missing_ids contains task IDs that were not found in cache.</p>"},{"location":"api/features.html#themap.features.cache.FeatureCache.clear","title":"clear","text":"<pre><code>clear(featurizer: Optional[str] = None) -&gt; int\n</code></pre> <p>Clear cached features.</p> <p>Parameters:</p> Name Type Description Default <code>featurizer</code> <code>Optional[str]</code> <p>If specified, only clear features for this featurizer.        If None, clear all cached features.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of files deleted.</p>"},{"location":"api/features.html#themap.features.cache.FeatureCache.get_statistics","title":"get_statistics","text":"<pre><code>get_statistics() -&gt; Dict[str, Any]\n</code></pre> <p>Get statistics about cached features.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with cache statistics.</p>"},{"location":"api/features.html#usage-examples_2","title":"Usage Examples","text":"<pre><code>from themap.features import FeatureCache\n\n# Initialize cache\ncache = FeatureCache(cache_dir=\"cache/features\")\n\n# Check if features are cached\ncache_key = \"ecfp_task1\"\nif cache.has(cache_key):\n    features = cache.load(cache_key)\nelse:\n    features = compute_features()\n    cache.save(cache_key, features)\n</code></pre>"},{"location":"api/features.html#automatic-caching","title":"Automatic Caching","text":"<pre><code>from themap.features import MoleculeFeaturizer, FeatureCache\n\ncache = FeatureCache(cache_dir=\"cache/\")\nfeaturizer = MoleculeFeaturizer(\n    featurizer_name=\"ecfp\",\n    cache=cache  # Enable automatic caching\n)\n\n# First call computes and caches\nfeatures1 = featurizer.featurize(smiles_list)\n\n# Second call loads from cache (fast)\nfeatures2 = featurizer.featurize(smiles_list)\n</code></pre>"},{"location":"api/features.html#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/features.html#choosing-the-right-featurizer","title":"Choosing the Right Featurizer","text":"<pre><code>def choose_featurizer(dataset_size: int, accuracy_priority: bool) -&gt; str:\n    \"\"\"Choose appropriate featurizer based on requirements.\"\"\"\n    if dataset_size &gt; 100000:\n        return \"ecfp\"  # Fast fingerprints for large datasets\n    elif accuracy_priority:\n        return \"ChemBERTa-77M-MLM\"  # Neural embeddings for accuracy\n    else:\n        return \"desc2D\"  # Good balance of speed and quality\n</code></pre>"},{"location":"api/features.html#parallel-processing","title":"Parallel Processing","text":"<pre><code>from themap.features import MoleculeFeaturizer\n\n# Use multiple CPU cores\nfeaturizer = MoleculeFeaturizer(\n    featurizer_name=\"mordred\",\n    n_jobs=16  # Use 16 parallel workers\n)\n</code></pre>"},{"location":"api/features.html#gpu-acceleration","title":"GPU Acceleration","text":"<pre><code>from themap.features import ProteinFeaturizer\n\n# Use GPU for neural models\nfeaturizer = ProteinFeaturizer(\n    model_name=\"esm2_t33_650M_UR50D\",\n    device=\"cuda:0\"  # Specific GPU\n)\n\n# Batch processing for efficiency\nembeddings = featurizer.featurize(\n    sequences,\n    batch_size=32  # Process 32 sequences at a time\n)\n</code></pre>"},{"location":"api/features.html#error-handling","title":"Error Handling","text":"<pre><code>from themap.features import MoleculeFeaturizer\n\nfeaturizer = MoleculeFeaturizer(featurizer_name=\"ecfp\")\n\n# Handle invalid SMILES\nsmiles_list = [\"CCO\", \"invalid_smiles\", \"CCCO\"]\n\ntry:\n    features = featurizer.featurize(smiles_list)\nexcept ValueError as e:\n    print(f\"Invalid SMILES: {e}\")\n\n# Or use safe mode\nfeatures = featurizer.featurize(\n    smiles_list,\n    on_error=\"skip\"  # Skip invalid molecules\n)\n</code></pre>"},{"location":"api/features.html#integration-with-distance-computation","title":"Integration with Distance Computation","text":"<pre><code>from themap.features import MoleculeFeaturizer\nfrom themap.distance import compute_dataset_distance_matrix\nimport numpy as np\n\n# Featurize datasets\nfeaturizer = MoleculeFeaturizer(featurizer_name=\"ecfp\")\n\nsource_features = featurizer.featurize(source_smiles)\ntarget_features = featurizer.featurize(target_smiles)\n\n# Compute distances\ndistances = compute_dataset_distance_matrix(\n    source_features,\n    target_features,\n    method=\"euclidean\"\n)\n</code></pre>"},{"location":"api/features.html#constants","title":"Constants","text":""},{"location":"api/features.html#available-featurizer-names","title":"Available Featurizer Names","text":"<pre><code>from themap.features.molecule import (\n    FINGERPRINT_FEATURIZERS,\n    DESCRIPTOR_FEATURIZERS,\n    NEURAL_FEATURIZERS,\n)\n\nprint(\"Fingerprints:\", FINGERPRINT_FEATURIZERS)\nprint(\"Descriptors:\", DESCRIPTOR_FEATURIZERS)\nprint(\"Neural:\", NEURAL_FEATURIZERS)\n</code></pre>"},{"location":"api/features.html#esm-model-names","title":"ESM Model Names","text":"<pre><code>from themap.features.protein import ESM2_MODELS, ESM3_MODELS\n\nprint(\"ESM2 models:\", ESM2_MODELS)\nprint(\"ESM3 models:\", ESM3_MODELS)\n</code></pre>"},{"location":"api/pipeline.html","title":"Pipeline Module","text":"<p>The pipeline module provides a high-level API for running distance computation workflows. It supports both programmatic and configuration-based approaches.</p>"},{"location":"api/pipeline.html#overview","title":"Overview","text":"<p>The pipeline system offers three levels of usage:</p> <ol> <li><code>quick_distance</code> - One-liner for simple computations</li> <li><code>run_pipeline</code> - Configuration file-based execution</li> <li><code>Pipeline</code> - Full programmatic control</li> </ol>"},{"location":"api/pipeline.html#quick-distance","title":"Quick Distance","text":"<p>The simplest way to compute distances:</p> <pre><code>from themap import quick_distance\n\nresults = quick_distance(\n    data_dir=\"datasets\",\n    output_dir=\"output\",\n    molecule_featurizer=\"ecfp\",\n    molecule_method=\"euclidean\",\n)\n</code></pre>"},{"location":"api/pipeline.html#function-reference","title":"Function Reference","text":""},{"location":"api/pipeline.html#themap.pipeline.orchestrator.quick_distance","title":"themap.pipeline.orchestrator.quick_distance","text":"<pre><code>quick_distance(\n    data_dir: str,\n    output_dir: str = \"output\",\n    molecule_featurizer: str = \"ecfp\",\n    molecule_method: str = \"euclidean\",\n    n_jobs: int = 8,\n) -&gt; Dict[str, DistanceMatrix]\n</code></pre> <p>Quick distance computation with minimal configuration.</p> <p>Parameters:</p> Name Type Description Default <code>data_dir</code> <code>str</code> <p>Path to data directory with train/test folders.</p> required <code>output_dir</code> <code>str</code> <p>Path to output directory.</p> <code>'output'</code> <code>molecule_featurizer</code> <code>str</code> <p>Molecule featurizer name.</p> <code>'ecfp'</code> <code>molecule_method</code> <code>str</code> <p>Distance method.</p> <code>'euclidean'</code> <code>n_jobs</code> <code>int</code> <p>Number of parallel jobs.</p> <code>8</code> <p>Returns:</p> Type Description <code>Dict[str, DistanceMatrix]</code> <p>Dictionary of distance matrices.</p>"},{"location":"api/pipeline.html#parameters","title":"Parameters","text":"Parameter Type Default Description <code>data_dir</code> str Required Directory with train/test folders <code>output_dir</code> str <code>\"output\"</code> Output directory for results <code>molecule_featurizer</code> str <code>\"ecfp\"</code> Molecular fingerprint type <code>molecule_method</code> str <code>\"euclidean\"</code> Distance metric <code>n_jobs</code> int <code>8</code> Parallel workers"},{"location":"api/pipeline.html#returns","title":"Returns","text":"<p>Dictionary with distance matrices:</p> <pre><code>{\n    \"molecule\": {\n        \"target_task_1\": {\n            \"source_task_1\": 0.75,\n            \"source_task_2\": 1.23,\n        },\n        \"target_task_2\": {...}\n    }\n}\n</code></pre>"},{"location":"api/pipeline.html#run-pipeline","title":"Run Pipeline","text":"<p>Execute a pipeline from a YAML configuration file:</p> <pre><code>from themap import run_pipeline\n\nresults = run_pipeline(\"config.yaml\")\n</code></pre>"},{"location":"api/pipeline.html#function-reference_1","title":"Function Reference","text":""},{"location":"api/pipeline.html#themap.pipeline.orchestrator.run_pipeline","title":"themap.pipeline.orchestrator.run_pipeline","text":"<pre><code>run_pipeline(config_path: str) -&gt; Dict[str, DistanceMatrix]\n</code></pre> <p>Convenience function to run pipeline from config file.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>Path to YAML config file.</p> required <p>Returns:</p> Type Description <code>Dict[str, DistanceMatrix]</code> <p>Dictionary of distance matrices.</p>"},{"location":"api/pipeline.html#configuration-file-format","title":"Configuration File Format","text":"<pre><code># config.yaml\ndata:\n  directory: \"datasets\"\n  task_list: null  # Auto-discover tasks\n\nmolecule:\n  enabled: true\n  featurizer: \"ecfp\"\n  method: \"euclidean\"\n\nprotein:\n  enabled: false\n\noutput:\n  directory: \"output\"\n  format: \"csv\"\n  save_features: true\n\ncompute:\n  n_jobs: 8\n  device: \"auto\"\n</code></pre>"},{"location":"api/pipeline.html#pipeline-class","title":"Pipeline Class","text":"<p>For full programmatic control:</p>"},{"location":"api/pipeline.html#pipeline","title":"Pipeline","text":""},{"location":"api/pipeline.html#themap.pipeline.orchestrator.Pipeline","title":"themap.pipeline.orchestrator.Pipeline","text":"<p>Main pipeline orchestrator for THEMAP distance computation.</p> <p>Orchestrates the complete workflow: 1. Load datasets from train/test directories 2. Compute molecule features (with caching) 3. Compute protein features (with caching, if enabled) 4. Compute distance matrices 5. Combine matrices (if needed) 6. Save results to output directory</p> <p>Attributes:</p> Name Type Description <code>config</code> <p>Pipeline configuration</p> <code>loader</code> <p>Dataset loader</p> <code>cache</code> <code>Optional[FeatureCache]</code> <p>Feature cache (if save_features is enabled)</p> <code>mol_featurizer</code> <code>MoleculeFeaturizer</code> <p>Molecule featurizer (if molecule distance enabled)</p> <code>prot_featurizer</code> <code>ProteinFeaturizer</code> <p>Protein featurizer (if protein distance enabled)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = PipelineConfig.from_yaml(\"config.yaml\")\n&gt;&gt;&gt; pipeline = Pipeline(config)\n&gt;&gt;&gt; results = pipeline.run()\n&gt;&gt;&gt; print(results[\"molecule\"])  # molecule distance matrix\n</code></pre>"},{"location":"api/pipeline.html#themap.pipeline.orchestrator.Pipeline.mol_featurizer","title":"mol_featurizer  <code>property</code>","text":"<pre><code>mol_featurizer: MoleculeFeaturizer\n</code></pre> <p>Get molecule featurizer (lazy initialization).</p>"},{"location":"api/pipeline.html#themap.pipeline.orchestrator.Pipeline.prot_featurizer","title":"prot_featurizer  <code>property</code>","text":"<pre><code>prot_featurizer: ProteinFeaturizer\n</code></pre> <p>Get protein featurizer (lazy initialization).</p>"},{"location":"api/pipeline.html#themap.pipeline.orchestrator.Pipeline.__init__","title":"__init__","text":"<pre><code>__init__(config: PipelineConfig)\n</code></pre> <p>Initialize the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PipelineConfig</code> <p>Pipeline configuration</p> required"},{"location":"api/pipeline.html#themap.pipeline.orchestrator.Pipeline.run","title":"run","text":"<pre><code>run() -&gt; Dict[str, DistanceMatrix]\n</code></pre> <p>Run the complete pipeline.</p> <p>Returns:</p> Type Description <code>Dict[str, DistanceMatrix]</code> <p>Dictionary mapping distance type to distance matrix:</p> <code>Dict[str, DistanceMatrix]</code> <ul> <li>\"molecule\": molecule distance matrix (if enabled)</li> </ul> <code>Dict[str, DistanceMatrix]</code> <ul> <li>\"protein\": protein distance matrix (if enabled)</li> </ul> <code>Dict[str, DistanceMatrix]</code> <ul> <li>\"combined\": combined matrix (if combination != \"separate\")</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no distance type is enabled</p>"},{"location":"api/pipeline.html#usage-example","title":"Usage Example","text":"<pre><code>from themap import Pipeline, PipelineConfig\nfrom themap.config import (\n    DataConfig,\n    MoleculeDistanceConfig,\n    OutputConfig,\n    ComputeConfig,\n)\nfrom pathlib import Path\n\n# Build configuration\nconfig = PipelineConfig(\n    data=DataConfig(\n        directory=Path(\"datasets\"),\n        task_list=None,\n    ),\n    molecule=MoleculeDistanceConfig(\n        enabled=True,\n        featurizer=\"ecfp\",\n        method=\"euclidean\",\n    ),\n    output=OutputConfig(\n        directory=Path(\"output\"),\n        format=\"csv\",\n        save_features=True,\n    ),\n    compute=ComputeConfig(\n        n_jobs=8,\n        device=\"auto\",\n    ),\n)\n\n# Create and run pipeline\npipeline = Pipeline(config)\nresults = pipeline.run()\n\n# Access results\nprint(f\"Computed distances for {len(results['molecule'])} target tasks\")\n</code></pre>"},{"location":"api/pipeline.html#configuration-classes","title":"Configuration Classes","text":""},{"location":"api/pipeline.html#pipelineconfig","title":"PipelineConfig","text":""},{"location":"api/pipeline.html#themap.config.PipelineConfig","title":"themap.config.PipelineConfig  <code>dataclass</code>","text":"<p>Main configuration for the THEMAP pipeline.</p> <p>Example YAML: <pre><code>data:\n  directory: \"datasets/TDC\"\n  task_list: \"tasks.json\"  # Optional\n\ndistances:\n  molecule:\n    enabled: true\n    featurizer: \"ecfp\"\n    method: \"euclidean\"\n  protein:\n    enabled: false\n    featurizer: \"esm2_t33_650M_UR50D\"\n    method: \"cosine\"\n\ncombination:\n  strategy: \"weighted_average\"\n  weights:\n    molecule: 0.7\n    protein: 0.3\n\noutput:\n  directory: \"output/\"\n  save_features: true\n\ncompute:\n  n_jobs: 8\n  batch_size: 1000\n</code></pre></p>"},{"location":"api/pipeline.html#themap.config.PipelineConfig.from_yaml","title":"from_yaml  <code>classmethod</code>","text":"<pre><code>from_yaml(path: Union[str, Path]) -&gt; PipelineConfig\n</code></pre> <p>Load configuration from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the YAML configuration file.</p> required <p>Returns:</p> Type Description <code>PipelineConfig</code> <p>PipelineConfig instance.</p>"},{"location":"api/pipeline.html#themap.config.PipelineConfig.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(config_dict: Dict[str, Any]) -&gt; PipelineConfig\n</code></pre> <p>Create configuration from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config_dict</code> <code>Dict[str, Any]</code> <p>Dictionary with configuration values.</p> required <p>Returns:</p> Type Description <code>PipelineConfig</code> <p>PipelineConfig instance.</p>"},{"location":"api/pipeline.html#themap.config.PipelineConfig.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert configuration to dictionary.</p>"},{"location":"api/pipeline.html#themap.config.PipelineConfig.to_yaml","title":"to_yaml","text":"<pre><code>to_yaml(path: Union[str, Path]) -&gt; None\n</code></pre> <p>Save configuration to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to save the YAML file.</p> required"},{"location":"api/pipeline.html#themap.config.PipelineConfig.validate","title":"validate","text":"<pre><code>validate() -&gt; List[str]\n</code></pre> <p>Validate configuration and return list of warnings/errors.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of warning/error messages.</p>"},{"location":"api/pipeline.html#dataconfig","title":"DataConfig","text":"<pre><code>from themap.config import DataConfig\nfrom pathlib import Path\n\ndata_config = DataConfig(\n    directory=Path(\"datasets\"),\n    task_list=[\"CHEMBL123\", \"CHEMBL456\"],  # Optional: specific tasks\n    source_fold=\"train\",\n    target_fold=\"test\",\n)\n</code></pre>"},{"location":"api/pipeline.html#moleculedistanceconfig","title":"MoleculeDistanceConfig","text":"<pre><code>from themap.config import MoleculeDistanceConfig\n\nmol_config = MoleculeDistanceConfig(\n    enabled=True,\n    featurizer=\"ecfp\",      # Fingerprint type\n    method=\"euclidean\",     # Distance method\n    cache_features=True,    # Cache computed features\n)\n</code></pre>"},{"location":"api/pipeline.html#proteindistanceconfig","title":"ProteinDistanceConfig","text":"<pre><code>from themap.config import ProteinDistanceConfig\n\nprot_config = ProteinDistanceConfig(\n    enabled=True,\n    featurizer=\"esm2_t33_650M_UR50D\",\n    method=\"euclidean\",\n)\n</code></pre>"},{"location":"api/pipeline.html#outputconfig","title":"OutputConfig","text":"<pre><code>from themap.config import OutputConfig\nfrom pathlib import Path\n\noutput_config = OutputConfig(\n    directory=Path(\"output\"),\n    format=\"csv\",           # csv, json, or parquet\n    save_features=True,     # Save computed features\n    save_matrices=True,     # Save distance matrices\n)\n</code></pre>"},{"location":"api/pipeline.html#computeconfig","title":"ComputeConfig","text":"<pre><code>from themap.config import ComputeConfig\n\ncompute_config = ComputeConfig(\n    n_jobs=8,               # Parallel workers\n    device=\"auto\",          # auto, cpu, or cuda\n    batch_size=1000,        # Batch size for processing\n)\n</code></pre>"},{"location":"api/pipeline.html#configuration-from-yaml","title":"Configuration from YAML","text":""},{"location":"api/pipeline.html#loading-configuration","title":"Loading Configuration","text":"<pre><code>from themap.config import PipelineConfig\n\n# Load from file\nconfig = PipelineConfig.from_yaml(\"config.yaml\")\n\n# Validate configuration\nissues = config.validate()\nif issues:\n    for issue in issues:\n        print(f\"Warning: {issue}\")\n</code></pre>"},{"location":"api/pipeline.html#saving-configuration","title":"Saving Configuration","text":"<pre><code>from themap.config import PipelineConfig\n\nconfig = PipelineConfig(...)\n\n# Save to file\nconfig.to_yaml(\"my_config.yaml\")\n</code></pre>"},{"location":"api/pipeline.html#output-files","title":"Output Files","text":"<p>The pipeline generates these output files:</p> <pre><code>output/\n\u251c\u2500\u2500 molecule_distances.csv       # Distance matrix\n\u251c\u2500\u2500 molecule_distances.json      # JSON format (if enabled)\n\u251c\u2500\u2500 features/                    # Cached features (if enabled)\n\u2502   \u251c\u2500\u2500 ecfp_source.npz\n\u2502   \u2514\u2500\u2500 ecfp_target.npz\n\u2514\u2500\u2500 pipeline_summary.json        # Execution summary\n</code></pre>"},{"location":"api/pipeline.html#distance-matrix-format-csv","title":"Distance Matrix Format (CSV)","text":"<pre><code>,CHEMBL111111,CHEMBL222222,CHEMBL333333\nCHEMBL123456,0.75,1.23,0.89\nCHEMBL789012,1.45,0.67,1.12\n</code></pre>"},{"location":"api/pipeline.html#summary-file","title":"Summary File","text":"<pre><code>{\n    \"pipeline_name\": \"molecule_distance\",\n    \"execution_time\": \"2.34s\",\n    \"datasets_processed\": {\n        \"source\": 10,\n        \"target\": 3\n    },\n    \"distance_computations\": 30,\n    \"config\": {...}\n}\n</code></pre>"},{"location":"api/pipeline.html#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/pipeline.html#custom-pipeline-steps","title":"Custom Pipeline Steps","text":"<pre><code>from themap import Pipeline, PipelineConfig\n\nclass CustomPipeline(Pipeline):\n    def run(self):\n        # Pre-processing\n        self.validate_data()\n\n        # Run standard pipeline\n        results = super().run()\n\n        # Post-processing\n        results = self.analyze_results(results)\n\n        return results\n\n    def validate_data(self):\n        \"\"\"Custom validation logic.\"\"\"\n        pass\n\n    def analyze_results(self, results):\n        \"\"\"Custom analysis.\"\"\"\n        return results\n</code></pre>"},{"location":"api/pipeline.html#combining-multiple-runs","title":"Combining Multiple Runs","text":"<pre><code>from themap import quick_distance\n\n# Run with different methods\nmethods = [\"euclidean\", \"cosine\"]\nall_results = {}\n\nfor method in methods:\n    results = quick_distance(\n        data_dir=\"datasets\",\n        molecule_method=method,\n        output_dir=f\"output_{method}\",\n    )\n    all_results[method] = results\n\n# Compare methods\nfor method, results in all_results.items():\n    print(f\"\\n{method.upper()} distances:\")\n    # Analyze results...\n</code></pre>"},{"location":"api/pipeline.html#incremental-processing","title":"Incremental Processing","text":"<pre><code>from themap import Pipeline, PipelineConfig\n\n# Process in batches\nconfig = PipelineConfig(...)\npipeline = Pipeline(config)\n\n# Get task lists\nsource_tasks = pipeline.get_source_tasks()\ntarget_tasks = pipeline.get_target_tasks()\n\n# Process incrementally\nbatch_size = 10\nall_results = {}\n\nfor i in range(0, len(target_tasks), batch_size):\n    batch_targets = target_tasks[i:i+batch_size]\n\n    batch_results = pipeline.run_for_targets(batch_targets)\n    all_results.update(batch_results)\n\n    print(f\"Processed {i+batch_size}/{len(target_tasks)} targets\")\n</code></pre>"},{"location":"api/pipeline.html#error-handling","title":"Error Handling","text":"<pre><code>from themap import run_pipeline\nfrom themap.pipeline import PipelineError\n\ntry:\n    results = run_pipeline(\"config.yaml\")\nexcept FileNotFoundError as e:\n    print(f\"Configuration file not found: {e}\")\nexcept PipelineError as e:\n    print(f\"Pipeline execution failed: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"api/pipeline.html#performance-tips","title":"Performance Tips","text":"<ol> <li>Use caching: Set <code>save_features: true</code> for repeated runs</li> <li>Choose fast methods: Use <code>euclidean</code> for exploration, <code>otdd</code> for final analysis</li> <li>Parallel processing: Increase <code>n_jobs</code> for multi-core systems</li> <li>GPU acceleration: Use <code>device: cuda</code> for protein featurizers</li> </ol> <pre><code># Optimized configuration\ncompute:\n  n_jobs: 16\n  device: \"cuda\"\n  batch_size: 2000\n\noutput:\n  save_features: true  # Cache for reuse\n</code></pre>"},{"location":"examples/index.html","title":"Examples","text":"<p>This section provides practical, runnable examples for common THEMAP use cases.</p>"},{"location":"examples/index.html#quick-start","title":"Quick Start","text":""},{"location":"examples/index.html#one-liner-distance-computation","title":"One-liner Distance Computation","text":"<pre><code>from themap import quick_distance\n\nresults = quick_distance(\n    data_dir=\"datasets\",          # Directory with train/ and test/ folders\n    output_dir=\"output\",          # Where to save results\n    molecule_featurizer=\"ecfp\",   # Fingerprint type\n    molecule_method=\"euclidean\",  # Distance metric\n)\n\n# Results saved to output/molecule_distances.csv\n</code></pre>"},{"location":"examples/index.html#using-a-config-file","title":"Using a Config File","text":"<pre><code>from themap import run_pipeline\n\nresults = run_pipeline(\"config.yaml\")\n</code></pre> <p>Example <code>config.yaml</code>: <pre><code>data:\n  directory: \"datasets\"\n\nmolecule:\n  enabled: true\n  featurizer: \"ecfp\"\n  method: \"euclidean\"\n\noutput:\n  directory: \"output\"\n  format: \"csv\"\n  save_features: true\n\ncompute:\n  n_jobs: 8\n</code></pre></p>"},{"location":"examples/index.html#full-programmatic-control","title":"Full Programmatic Control","text":"<pre><code>from themap import Pipeline, PipelineConfig\nfrom themap.config import DataConfig, MoleculeDistanceConfig, OutputConfig\n\nconfig = PipelineConfig(\n    data=DataConfig(directory=Path(\"datasets\")),\n    molecule=MoleculeDistanceConfig(\n        enabled=True,\n        featurizer=\"ecfp\",\n        method=\"euclidean\"\n    ),\n    output=OutputConfig(\n        directory=Path(\"output\"),\n        format=\"csv\"\n    ),\n)\n\npipeline = Pipeline(config)\nresults = pipeline.run()\n</code></pre>"},{"location":"examples/index.html#analyzing-results","title":"Analyzing Results","text":""},{"location":"examples/index.html#load-and-explore-distance-matrix","title":"Load and Explore Distance Matrix","text":"<pre><code>import pandas as pd\n\n# Load computed distances\ndistances = pd.read_csv(\"output/molecule_distances.csv\", index_col=0)\n\nprint(f\"Shape: {distances.shape}\")\nprint(f\"Sources: {list(distances.index)}\")\nprint(f\"Targets: {list(distances.columns)}\")\n</code></pre>"},{"location":"examples/index.html#find-closest-source-for-each-target","title":"Find Closest Source for Each Target","text":"<pre><code>import pandas as pd\n\ndistances = pd.read_csv(\"output/molecule_distances.csv\", index_col=0)\n\nfor target in distances.columns:\n    closest = distances[target].idxmin()\n    dist = distances[target].min()\n    print(f\"{target} &lt;- {closest} (distance: {dist:.4f})\")\n</code></pre>"},{"location":"examples/index.html#estimate-task-hardness","title":"Estimate Task Hardness","text":"<pre><code>import pandas as pd\n\ndistances = pd.read_csv(\"output/molecule_distances.csv\", index_col=0)\n\n# Task hardness = average distance to k-nearest sources\nk = 3\nfor target in distances.columns:\n    hardness = distances[target].nsmallest(k).mean()\n    print(f\"Hardness for {target}: {hardness:.4f}\")\n</code></pre>"},{"location":"examples/index.html#comparing-distance-methods","title":"Comparing Distance Methods","text":"<pre><code>import time\nfrom themap import quick_distance\n\nmethods = [\"euclidean\", \"cosine\"]\n\nfor method in methods:\n    start = time.time()\n    results = quick_distance(\n        data_dir=\"datasets\",\n        molecule_method=method,\n    )\n    elapsed = time.time() - start\n    print(f\"{method}: {elapsed:.2f}s\")\n</code></pre>"},{"location":"examples/index.html#visualization","title":"Visualization","text":""},{"location":"examples/index.html#distance-matrix-heatmap","title":"Distance Matrix Heatmap","text":"<pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load distances\ndistances = pd.read_csv(\"output/molecule_distances.csv\", index_col=0)\n\n# Create heatmap\nplt.figure(figsize=(10, 8))\nsns.heatmap(\n    distances,\n    annot=True,\n    fmt='.3f',\n    cmap='viridis',\n    cbar_kws={'label': 'Distance'},\n)\n\nplt.title(\"Dataset Distances\")\nplt.xlabel(\"Target Tasks\")\nplt.ylabel(\"Source Tasks\")\nplt.tight_layout()\nplt.savefig(\"distance_heatmap.png\", dpi=300)\nplt.show()\n</code></pre>"},{"location":"examples/index.html#data-format","title":"Data Format","text":""},{"location":"examples/index.html#directory-structure","title":"Directory Structure","text":"<pre><code>datasets/\n\u251c\u2500\u2500 train/                        # Source datasets\n\u2502   \u251c\u2500\u2500 CHEMBL123456.jsonl.gz\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 test/                         # Target datasets\n    \u251c\u2500\u2500 CHEMBL111111.jsonl.gz\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"examples/index.html#jsonlgz-file-format","title":"JSONL.GZ File Format","text":"<p>Each file contains molecules in JSON lines format: <pre><code>{\"SMILES\": \"CCO\", \"Property\": 1}\n{\"SMILES\": \"CCCO\", \"Property\": 0}\n</code></pre></p>"},{"location":"examples/index.html#command-line-usage","title":"Command Line Usage","text":"<pre><code># Run quickstart example\npython examples/quickstart.py --data datasets --featurizer ecfp --method euclidean\n\n# With config file\npython examples/quickstart.py --config config.yaml\n</code></pre>"},{"location":"examples/index.html#available-options","title":"Available Options","text":""},{"location":"examples/index.html#featurizers","title":"Featurizers","text":"Featurizer Description <code>ecfp</code> Extended Connectivity Fingerprints (fast) <code>maccs</code> MACCS structural keys (fast) <code>desc2D</code> 2D molecular descriptors <code>desc3D</code> 3D molecular descriptors"},{"location":"examples/index.html#distance-methods","title":"Distance Methods","text":"Method Description <code>euclidean</code> Fast Euclidean distance <code>cosine</code> Cosine distance <code>otdd</code> Optimal Transport Dataset Distance (slow but accurate) <p>For more detailed explanations, see our tutorials.</p>"},{"location":"tutorials/index.html","title":"Tutorials","text":"<p>Welcome to the THEMAP tutorials! These step-by-step guides will help you master task hardness estimation and distance computation for molecular activity prediction.</p>"},{"location":"tutorials/index.html#tutorial-overview","title":"Tutorial Overview","text":""},{"location":"tutorials/index.html#beginner-tutorials","title":"\ud83d\ude80 Beginner Tutorials","text":"<ol> <li>Getting Started - Basic installation and first steps</li> </ol>"},{"location":"tutorials/index.html#interactive-notebooks","title":"Interactive Notebooks","text":"<p>All tutorials are available as interactive Jupyter notebooks that you can run locally:</p> <pre><code># Install notebook dependencies\npip install -e \".[dev]\"\n\n# Launch Jupyter Lab\njupyter lab docs/tutorials/\n</code></pre> <pre><code># Download tutorial data (if not included)\nfrom themap.utils import download_tutorial_data\n\ndownload_tutorial_data(\"tutorials/data/\")\n</code></pre>"},{"location":"tutorials/index.html#sample-datasets","title":"Sample Datasets","text":"<ul> <li>ChEMBL Bioactivity Data: 10 training + 3 test tasks</li> <li>Protein Sequences: Target protein sequences for each task</li> <li>Molecular Embeddings: Pre-computed molecular features</li> <li>Metadata: Assay descriptions and experimental conditions</li> </ul>"},{"location":"tutorials/index.html#prerequisites","title":"Prerequisites","text":""},{"location":"tutorials/index.html#python-knowledge","title":"Python Knowledge","text":"<ul> <li>Basic Python programming</li> <li>Familiarity with NumPy and Pandas</li> <li>Optional: Jupyter notebook experience</li> </ul>"},{"location":"tutorials/index.html#domain-knowledge","title":"Domain Knowledge","text":"<ul> <li>Basic understanding of molecular representations (SMILES, etc.)</li> <li>Familiarity with machine learning concepts</li> <li>Optional: Knowledge of protein sequences and drug discovery</li> </ul>"},{"location":"tutorials/index.html#computational-resources","title":"Computational Resources","text":"<p>Most tutorials can run on: - CPU: Standard laptop/desktop (8GB+ RAM recommended) - GPU: Optional, speeds up OTDD computations - Storage: ~1GB for tutorial data and caches</p>"},{"location":"tutorials/index.html#getting-help","title":"Getting Help","text":""},{"location":"tutorials/index.html#tutorial-support","title":"Tutorial Support","text":"<p>If you encounter issues with tutorials:</p> <ol> <li>Check Prerequisites: Ensure all dependencies are installed</li> <li>Verify Data: Confirm tutorial data is properly downloaded</li> <li>Read Error Messages: THEMAP provides detailed error information</li> <li>Ask Questions: Open an issue on GitHub</li> </ol>"},{"location":"tutorials/index.html#common-issues","title":"Common Issues","text":"<pre><code># Installation issues\npip install -e \".[all]\"  # Install all dependencies\n\n# Memory issues\n# Use smaller datasets or batch processing\n\n# GPU issues\nimport torch\nprint(f\"CUDA available: {torch.cuda.is_available()}\")\n</code></pre>"},{"location":"tutorials/index.html#community","title":"Community","text":"<ul> <li>GitHub Discussions: Share experiences and ask questions</li> <li>Issues: Report bugs or request features</li> <li>Contributions: Submit improvements to tutorials</li> </ul>"},{"location":"tutorials/index.html#contributing-to-tutorials","title":"Contributing to Tutorials","text":"<p>We welcome contributions! To add or improve tutorials:</p> <ol> <li>Fork the repository</li> <li>Create tutorial content in Markdown and/or Jupyter format</li> <li>Test thoroughly with different environments</li> <li>Submit pull request with clear description</li> </ol>"},{"location":"tutorials/index.html#tutorial-guidelines","title":"Tutorial Guidelines","text":"<ul> <li>Clear objectives: State what readers will learn</li> <li>Step-by-step: Break complex tasks into manageable steps</li> <li>Code examples: Include runnable code snippets</li> <li>Error handling: Show how to handle common issues</li> <li>Real data: Use realistic examples when possible</li> </ul>"},{"location":"tutorials/index.html#whats-next","title":"What's Next?","text":"<p>Ready to get started? Here are recommended next steps:</p> <ul> <li>New to THEMAP? \u2192 Getting Started</li> </ul> <p>Happy learning! \ud83e\uddea\ud83d\udd2c\ud83d\udcca</p>"},{"location":"tutorials/Basics.html","title":"Importing Required Libraries","text":"In\u00a0[1]: Copied! <pre># import general packages\nimport os\nimport sys\n\nimport pandas as pd\nimport torch\nfrom dpu_utils.utils.richpath import RichPath\nfrom tqdm.notebook import tqdm\n\n# Setting up local details:\n# This should be the location of the checkout of the THEMAP repository:\nrepo_path = os.path.dirname(os.path.abspath(\"\"))\nCHECKOUT_PATH = repo_path\nDATASET_PATH = os.path.join(repo_path, \"datasets\")\n\nos.chdir(CHECKOUT_PATH)\nsys.path.insert(0, CHECKOUT_PATH)\n</pre> # import general packages import os import sys  import pandas as pd import torch from dpu_utils.utils.richpath import RichPath from tqdm.notebook import tqdm  # Setting up local details: # This should be the location of the checkout of the THEMAP repository: repo_path = os.path.dirname(os.path.abspath(\"\")) CHECKOUT_PATH = repo_path DATASET_PATH = os.path.join(repo_path, \"datasets\")  os.chdir(CHECKOUT_PATH) sys.path.insert(0, CHECKOUT_PATH) In\u00a0[2]: Copied! <pre>from third_party.otdd.otdd.pytorch.datasets import MolDataset, load_molecule_data\nfrom third_party.otdd.otdd.pytorch.distance import DatasetDistance\n</pre> from third_party.otdd.otdd.pytorch.datasets import MolDataset, load_molecule_data from third_party.otdd.otdd.pytorch.distance import DatasetDistance <pre>ot.gpu not found - coupling computation will be in cpu\n</pre> In\u00a0[3]: Copied! <pre># import visualization packages\n%matplotlib inline\n\nimport ipywidgets as widgets\nimport matplotlib\nimport matplotlib.pyplot as plt\n\nfrom themap.data import MoleculeDataset, ProteinDataset\n\nlight_color = plt.get_cmap(\"plasma\").colors[170]\ndark_color = \"black\"\n\nmatplotlib.rcParams.update(\n    {\n        \"pgf.texsystem\": \"pdflatex\",\n        \"font.family\": \"serif\",\n        \"font.serif\": \"Computer Modern Roman\",\n        \"font.size\": 20,\n        \"text.usetex\": True,\n        \"pgf.rcfonts\": False,\n    }\n)\n</pre> # import visualization packages %matplotlib inline  import ipywidgets as widgets import matplotlib import matplotlib.pyplot as plt  from themap.data import MoleculeDataset, ProteinDataset  light_color = plt.get_cmap(\"plasma\").colors[170] dark_color = \"black\"  matplotlib.rcParams.update(     {         \"pgf.texsystem\": \"pdflatex\",         \"font.family\": \"serif\",         \"font.serif\": \"Computer Modern Roman\",         \"font.size\": 20,         \"text.usetex\": True,         \"pgf.rcfonts\": False,     } ) In\u00a0[4]: Copied! <pre>source_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"train\", \"CHEMBL1023359.jsonl.gz\"))\ntarget_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"test\", \"CHEMBL2219358.jsonl.gz\"))\n\nsource_dataset = MoleculeDataset.load_from_file(source_dataset_path)\ntarget_dataset = MoleculeDataset.load_from_file(target_dataset_path)\n</pre> source_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"train\", \"CHEMBL1023359.jsonl.gz\")) target_dataset_path = RichPath.create(os.path.join(DATASET_PATH, \"test\", \"CHEMBL2219358.jsonl.gz\"))  source_dataset = MoleculeDataset.load_from_file(source_dataset_path) target_dataset = MoleculeDataset.load_from_file(target_dataset_path) In\u00a0[5]: Copied! <pre>Molecule_Feaurizer = widgets.Dropdown(\n    options=[\"gin_supervised_infomax\", \"gin_supervised_masking\", \"gin_supervised_edgepred\"],\n    value=\"gin_supervised_infomax\",\n    description=\"Molecule Featurizer:\",\n    disabled=False,\n)\n</pre> Molecule_Feaurizer = widgets.Dropdown(     options=[\"gin_supervised_infomax\", \"gin_supervised_masking\", \"gin_supervised_edgepred\"],     value=\"gin_supervised_infomax\",     description=\"Molecule Featurizer:\",     disabled=False, ) In\u00a0[6]: Copied! <pre>Molecule_Feaurizer\n</pre> Molecule_Feaurizer Out[6]: <pre>Dropdown(description='Molecule Featurizer:', options=('gin_supervised_infomax', 'gin_supervised_masking', 'gin\u2026</pre> In\u00a0[7]: Copied! <pre>## compute and load the embeddings\nmolecule_feaurizer = Molecule_Feaurizer.value\nsource_features = source_dataset.get_features(molecule_feaurizer)\ntarget_features = target_dataset.get_features(molecule_feaurizer)\nassert source_features.shape[1] == target_features.shape[1]\n</pre> ## compute and load the embeddings molecule_feaurizer = Molecule_Feaurizer.value source_features = source_dataset.get_features(molecule_feaurizer) target_features = target_dataset.get_features(molecule_feaurizer) assert source_features.shape[1] == target_features.shape[1] In\u00a0[8]: Copied! <pre>source_dataset_otdd = MolDataset(source_dataset)\ntarget_dataset_otdd = MolDataset(target_dataset)\n</pre> source_dataset_otdd = MolDataset(source_dataset) target_dataset_otdd = MolDataset(target_dataset) In\u00a0[9]: Copied! <pre>source_dataset_loader = load_molecule_data(source_dataset)\ntarget_dataset_loader = load_molecule_data(target_dataset)\n</pre> source_dataset_loader = load_molecule_data(source_dataset) target_dataset_loader = load_molecule_data(target_dataset) In\u00a0[\u00a0]: Copied! <pre># Instantiate distance\ndist = DatasetDistance(\n    source_dataset_loader,\n    target_dataset_loader,\n    inner_ot_method=\"exact\",\n    debiased_loss=True,\n    p=2,\n    entreg=1e-1,\n    device=\"cuda\" if torch.cuda.is_available() else \"cpu\",\n)\n\nd = dist.distance(maxsamples=1000)\nprint(f\"OTDD(src,tgt)={d}\")\n</pre> # Instantiate distance dist = DatasetDistance(     source_dataset_loader,     target_dataset_loader,     inner_ot_method=\"exact\",     debiased_loss=True,     p=2,     entreg=1e-1,     device=\"cuda\" if torch.cuda.is_available() else \"cpu\", )  d = dist.distance(maxsamples=1000) print(f\"OTDD(src,tgt)={d}\") In\u00a0[\u00a0]: Copied! <pre>import glob\n\nsource_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"train\", \"CHEMBL*\"))\ntarget_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"test\", \"CHEMBL*\"))\nchem_distances = {}\nfor target_path in tqdm(target_datasets_path):\n    chem_distance = {}\n    target_dataset_path = RichPath.create(target_path)\n    target_dataset = MoleculeDataset.load_from_file(target_dataset_path)\n    target_features = target_dataset.get_features(molecule_feaurizer)\n    target_dataset_otdd = MolDataset(target_dataset)\n    target_dataset_loader = load_molecule_data(target_dataset)\n    for source_path in source_datasets_path:\n        source_dataset_path = RichPath.create(source_path)\n        source_dataset = MoleculeDataset.load_from_file(source_dataset_path)\n        source_features = source_dataset.get_features(molecule_feaurizer)\n        source_dataset_otdd = MolDataset(source_dataset)\n        source_dataset_loader = load_molecule_data(source_dataset)\n\n        dist = DatasetDistance(\n            source_dataset_loader,\n            target_dataset_loader,\n            inner_ot_method=\"exact\",\n            debiased_loss=True,\n            p=2,\n            entreg=1e-1,\n            device=\"cuda\" if torch.cuda.is_available() else \"cpu\",\n        )\n\n        d = dist.distance(maxsamples=1000)\n        print(f\"OTDD({source_dataset.task_id},{target_dataset.task_id})= {d}\")\n        chem_distance[source_dataset.task_id] = d.cpu().item()\n    chem_distances[target_dataset.task_id] = chem_distance\n</pre> import glob  source_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"train\", \"CHEMBL*\")) target_datasets_path = glob.glob(os.path.join(DATASET_PATH, \"test\", \"CHEMBL*\")) chem_distances = {} for target_path in tqdm(target_datasets_path):     chem_distance = {}     target_dataset_path = RichPath.create(target_path)     target_dataset = MoleculeDataset.load_from_file(target_dataset_path)     target_features = target_dataset.get_features(molecule_feaurizer)     target_dataset_otdd = MolDataset(target_dataset)     target_dataset_loader = load_molecule_data(target_dataset)     for source_path in source_datasets_path:         source_dataset_path = RichPath.create(source_path)         source_dataset = MoleculeDataset.load_from_file(source_dataset_path)         source_features = source_dataset.get_features(molecule_feaurizer)         source_dataset_otdd = MolDataset(source_dataset)         source_dataset_loader = load_molecule_data(source_dataset)          dist = DatasetDistance(             source_dataset_loader,             target_dataset_loader,             inner_ot_method=\"exact\",             debiased_loss=True,             p=2,             entreg=1e-1,             device=\"cuda\" if torch.cuda.is_available() else \"cpu\",         )          d = dist.distance(maxsamples=1000)         print(f\"OTDD({source_dataset.task_id},{target_dataset.task_id})= {d}\")         chem_distance[source_dataset.task_id] = d.cpu().item()     chem_distances[target_dataset.task_id] = chem_distance In\u00a0[12]: Copied! <pre>## Choose your target from chem_distances.keys()\nyour_tasks = \"CHEMBL2219236\"\nchem_dist = chem_distances[your_tasks]\nfig = plt.figure(figsize=(12, 5))\nplt.bar(chem_dist.keys(), chem_dist.values())\nplt.xlabel(\"Source datasets\")\nplt.ylabel(\"OTDD\")\nplt.title(f\"OTDD between source datasets and target {your_tasks}\")\nplt.xticks(rotation=90)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=1.0)\nplt.show()\n</pre> ## Choose your target from chem_distances.keys() your_tasks = \"CHEMBL2219236\" chem_dist = chem_distances[your_tasks] fig = plt.figure(figsize=(12, 5)) plt.bar(chem_dist.keys(), chem_dist.values()) plt.xlabel(\"Source datasets\") plt.ylabel(\"OTDD\") plt.title(f\"OTDD between source datasets and target {your_tasks}\") plt.xticks(rotation=90) plt.grid(axis=\"y\", linestyle=\"--\", alpha=1.0) plt.show() In\u00a0[15]: Copied! <pre>chem_distances.keys()\n</pre> chem_distances.keys() Out[15]: <pre>dict_keys(['CHEMBL2219236', 'CHEMBL1963831', 'CHEMBL2219358'])</pre> In\u00a0[13]: Copied! <pre>Protein_Feaurizer = widgets.Dropdown(\n    options=[\n        \"esm2_t6_8M_UR50D\",\n        \"esm2_t12_35M_UR50D\",\n        \"esm2_t30_150M_UR50D\",\n        \"esm2_t33_650M_UR50D\",\n        \"esm2_t36_3B_UR50D\",\n    ],\n    value=\"esm2_t33_650M_UR50D\",\n    description=\"Protein Featurizer:\",\n    disabled=False,\n)\n</pre> Protein_Feaurizer = widgets.Dropdown(     options=[         \"esm2_t6_8M_UR50D\",         \"esm2_t12_35M_UR50D\",         \"esm2_t30_150M_UR50D\",         \"esm2_t33_650M_UR50D\",         \"esm2_t36_3B_UR50D\",     ],     value=\"esm2_t33_650M_UR50D\",     description=\"Protein Featurizer:\",     disabled=False, ) In\u00a0[14]: Copied! <pre>Protein_Feaurizer\n</pre> Protein_Feaurizer Out[14]: <pre>Dropdown(description='Protein Featurizer:', index=3, options=('esm2_t6_8M_UR50D', 'esm2_t12_35M_UR50D', 'esm2_\u2026</pre> In\u00a0[15]: Copied! <pre>source_protein = ProteinDataset.load_from_file(\"datasets/train/train_proteins.fasta\")\ntarget_protein = ProteinDataset.load_from_file(\"datasets/test/test_proteins.fasta\")\n</pre> source_protein = ProteinDataset.load_from_file(\"datasets/train/train_proteins.fasta\") target_protein = ProteinDataset.load_from_file(\"datasets/test/test_proteins.fasta\") In\u00a0[16]: Copied! <pre>protein_featurizer = Protein_Feaurizer.value\nsource_protein_features = source_protein.get_features(protein_featurizer)\ntarget_protein_features = target_protein.get_features(protein_featurizer)\n</pre> protein_featurizer = Protein_Feaurizer.value source_protein_features = source_protein.get_features(protein_featurizer) target_protein_features = target_protein.get_features(protein_featurizer) In\u00a0[17]: Copied! <pre>from scipy.spatial.distance import cdist\n\ndist = cdist(source_protein.features, target_protein.features)\n</pre> from scipy.spatial.distance import cdist  dist = cdist(source_protein.features, target_protein.features) In\u00a0[18]: Copied! <pre>prot_distances = {}\nfor i, target_prot in enumerate(target_protein.task_id):\n    prot_distance = {}\n    for j, source_prot in enumerate(source_protein.task_id):\n        prot_distance[source_prot] = dist[j, i]\n    prot_distances[target_prot] = prot_distance\n</pre> prot_distances = {} for i, target_prot in enumerate(target_protein.task_id):     prot_distance = {}     for j, source_prot in enumerate(source_protein.task_id):         prot_distance[source_prot] = dist[j, i]     prot_distances[target_prot] = prot_distance In\u00a0[24]: Copied! <pre>## Choose your target from chem_distances.keys()\nyour_tasks = \"CHEMBL2219236\"\nprot_dist = prot_distances[your_tasks]\nfig = plt.figure(figsize=(12, 5))\nplt.bar(prot_dist.keys(), prot_dist.values())\nplt.xlabel(\"Source datasets\")\nplt.ylabel(\"Protein Distance\")\nplt.title(f\"Protein Distance between source datasets and target {your_tasks}\")\nplt.xticks(rotation=90)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=1.0)\nplt.show()\n</pre> ## Choose your target from chem_distances.keys() your_tasks = \"CHEMBL2219236\" prot_dist = prot_distances[your_tasks] fig = plt.figure(figsize=(12, 5)) plt.bar(prot_dist.keys(), prot_dist.values()) plt.xlabel(\"Source datasets\") plt.ylabel(\"Protein Distance\") plt.title(f\"Protein Distance between source datasets and target {your_tasks}\") plt.xticks(rotation=90) plt.grid(axis=\"y\", linestyle=\"--\", alpha=1.0) plt.show() <p>Now, we can answer to the following questions:</p> <ul> <li>Given a target task, what is the closest source task in terms of chemical and protein distances?</li> <li>Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space?</li> <li>Given a target task and source tasks, how to pick the k nearset source tasks fo transfer learning?</li> </ul> <p>So, let's answer to this questions in the following sections.</p> In\u00a0[42]: Copied! <pre>chem_df = pd.DataFrame.from_dict(chem_distances)\nprot_df = pd.DataFrame.from_dict(prot_distances)\n</pre> chem_df = pd.DataFrame.from_dict(chem_distances) prot_df = pd.DataFrame.from_dict(prot_distances) In\u00a0[69]: Copied! <pre>## Given a target task, what is the closest source task in terms of chemical and protein distances?\nyour_task = \"CHEMBL2219236\"\n\nchem_distance = chem_df[your_task]\nprot_distance = prot_df[your_task]\n\nnormalized_chem_distance = (chem_distance - chem_distance.min()) / (chem_distance.max() - chem_distance.min())\nnormalized_prot_distance = (prot_distance - prot_distance.min()) / (prot_distance.max() - prot_distance.min())\nnormalized_prot_distance = normalized_prot_distance.reindex(normalized_chem_distance.index)\nnormalized_comb_distance = (normalized_chem_distance + normalized_prot_distance) / 2\n\n\nprint(f\"Closest source task in terms of chemical distance: {chem_distance.idxmin()}\")\nprint(f\"Closest source task in terms of protein distance: {prot_distance.idxmin()}\")\nprint(\n    f\"Closest source task in terms of combination of chemical and protein distance: {normalized_comb_distance.idxmin()}\"\n)\n</pre> ## Given a target task, what is the closest source task in terms of chemical and protein distances? your_task = \"CHEMBL2219236\"  chem_distance = chem_df[your_task] prot_distance = prot_df[your_task]  normalized_chem_distance = (chem_distance - chem_distance.min()) / (chem_distance.max() - chem_distance.min()) normalized_prot_distance = (prot_distance - prot_distance.min()) / (prot_distance.max() - prot_distance.min()) normalized_prot_distance = normalized_prot_distance.reindex(normalized_chem_distance.index) normalized_comb_distance = (normalized_chem_distance + normalized_prot_distance) / 2   print(f\"Closest source task in terms of chemical distance: {chem_distance.idxmin()}\") print(f\"Closest source task in terms of protein distance: {prot_distance.idxmin()}\") print(     f\"Closest source task in terms of combination of chemical and protein distance: {normalized_comb_distance.idxmin()}\" ) <pre>Closest source task in terms of chemical distance: CHEMBL2218944\nClosest source task in terms of protein distance: CHEMBL2219012\nClosest source task in terms of combination of chemical and protein distance: CHEMBL2219012\n</pre> In\u00a0[91]: Copied! <pre>## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space?\n## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks.\nk = 3\n\ntarget_tasks = chem_df.columns\nsource_tasks = chem_df.index\n\nhardness_all = {}\nfor target_task in target_tasks:\n    hardness = {}\n    chem_distance = chem_df[target_task]\n    prot_distance = prot_df[target_task]\n\n    chem_distance = chem_distance.sort_values()\n    prot_distance = prot_distance.sort_values()\n\n    hardness[\"EXT_CHEM\"] = chem_distance[:k].sum() / k\n    hardness[\"EXT_PROT\"] = prot_distance[:k].sum() / k\n\n    hardness_all[target_task] = hardness\n\nhardness_df = pd.DataFrame.from_dict(hardness_all).T\nhardness_df[\"all\"] = (hardness_df[\"EXT_CHEM\"] + hardness_df[\"EXT_PROT\"]) / 2\n\nprint(f\"Easiest target task in terms of chemical distance: {hardness_df['EXT_CHEM'].idxmin()}\")\nprint(f\"Easiest target task in terms of protein distance: {hardness_df['EXT_PROT'].idxmin()}\")\nprint(\n    f\"Easiest target task in terms of combination of chemical and protein distance: {hardness_df['all'].idxmin()}\"\n)\n</pre> ## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space? ## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks. k = 3  target_tasks = chem_df.columns source_tasks = chem_df.index  hardness_all = {} for target_task in target_tasks:     hardness = {}     chem_distance = chem_df[target_task]     prot_distance = prot_df[target_task]      chem_distance = chem_distance.sort_values()     prot_distance = prot_distance.sort_values()      hardness[\"EXT_CHEM\"] = chem_distance[:k].sum() / k     hardness[\"EXT_PROT\"] = prot_distance[:k].sum() / k      hardness_all[target_task] = hardness  hardness_df = pd.DataFrame.from_dict(hardness_all).T hardness_df[\"all\"] = (hardness_df[\"EXT_CHEM\"] + hardness_df[\"EXT_PROT\"]) / 2  print(f\"Easiest target task in terms of chemical distance: {hardness_df['EXT_CHEM'].idxmin()}\") print(f\"Easiest target task in terms of protein distance: {hardness_df['EXT_PROT'].idxmin()}\") print(     f\"Easiest target task in terms of combination of chemical and protein distance: {hardness_df['all'].idxmin()}\" ) <pre>Easiest target task in terms of chemical distance: CHEMBL2219236\nEasiest target task in terms of protein distance: CHEMBL2219358\nEasiest target task in terms of combination of chemical and protein distance: CHEMBL2219358\n</pre> In\u00a0[93]: Copied! <pre>plt.figure(figsize=(12, 5))\nplt.bar(hardness_df.index, hardness_df[\"all\"])\nplt.xlabel(\"Target datasets\")\nplt.ylabel(\"Hardness\")\nplt.title(\"Hardness of target datasets\")\nplt.xticks(rotation=90)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=1.0)\nplt.show()\n</pre> plt.figure(figsize=(12, 5)) plt.bar(hardness_df.index, hardness_df[\"all\"]) plt.xlabel(\"Target datasets\") plt.ylabel(\"Hardness\") plt.title(\"Hardness of target datasets\") plt.xticks(rotation=90) plt.grid(axis=\"y\", linestyle=\"--\", alpha=1.0) plt.show() In\u00a0[103]: Copied! <pre>## Given a target task and source tasks, how to pick the k nearset source tasks fo transfer learning?\n## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space?\n## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks.\nk = 3\n\ntarget_tasks = chem_df.columns\nsource_tasks = chem_df.index\n\nclosest_tasks = {}\nfor target_task in target_tasks:\n    closest = {}\n    chem_distance = chem_df[target_task]\n    prot_distance = prot_df[target_task]\n\n    chem_distance = chem_distance.sort_values()\n    prot_distance = prot_distance.sort_values()\n\n    closest[\"EXT_CHEM\"] = chem_distance[:k].index.to_list()\n    closest[\"EXT_PROT\"] = prot_distance[:k].index.to_list()\n\n    closest_tasks[target_task] = closest\n\nclosest_df = pd.DataFrame.from_dict(closest_tasks).T\n</pre> ## Given a target task and source tasks, how to pick the k nearset source tasks fo transfer learning? ## Given the source tasks, which target task is hardest to transfer to in terms of chemical and protein space? ## Answering this question require to define hardness, which we consider here as the average of k-nearest source tasks. k = 3  target_tasks = chem_df.columns source_tasks = chem_df.index  closest_tasks = {} for target_task in target_tasks:     closest = {}     chem_distance = chem_df[target_task]     prot_distance = prot_df[target_task]      chem_distance = chem_distance.sort_values()     prot_distance = prot_distance.sort_values()      closest[\"EXT_CHEM\"] = chem_distance[:k].index.to_list()     closest[\"EXT_PROT\"] = prot_distance[:k].index.to_list()      closest_tasks[target_task] = closest  closest_df = pd.DataFrame.from_dict(closest_tasks).T"},{"location":"tutorials/Basics.html#importing-required-libraries","title":"Importing Required Libraries\u00b6","text":"<p>First, we are importing the libraries and modules that are required for running this notebook.</p>"},{"location":"tutorials/Basics.html#create-source-and-target-datasets-data","title":"Create source and target datasets (Data)\u00b6","text":""},{"location":"tutorials/Basics.html#calculate-chemcial-distance-between-target-datasets-with-all-the-source-datasets","title":"Calculate chemcial distance between target datasets with all the source datasets\u00b6","text":""},{"location":"tutorials/Basics.html#calculate-protein-distance-between-target-datasets-with-all-the-source-datasets","title":"Calculate protein distance between target datasets with all the source datasets\u00b6","text":""},{"location":"tutorials/Basics.html#combine-two-distances","title":"Combine Two Distances\u00b6","text":""},{"location":"tutorials/basic-distance-computation.html","title":"Basic Distance Computation","text":"<p>This tutorial covers the fundamentals of computing distances between molecular datasets using THEMAP.</p>"},{"location":"tutorials/basic-distance-computation.html#overview","title":"Overview","text":"<p>Distance computation is at the core of THEMAP's functionality. This tutorial will show you how to:</p> <ol> <li>Choose appropriate distance metrics</li> <li>Configure distance calculations</li> <li>Analyze results</li> <li>Optimize performance</li> </ol>"},{"location":"tutorials/basic-distance-computation.html#quick-start","title":"Quick Start","text":"<p>The simplest way to compute distances:</p> <pre><code>from themap import quick_distance\n\nresults = quick_distance(\n    data_dir=\"datasets\",\n    output_dir=\"output\",\n    molecule_featurizer=\"ecfp\",\n    molecule_method=\"euclidean\",\n)\n</code></pre>"},{"location":"tutorials/basic-distance-computation.html#distance-methods-comparison","title":"Distance Methods Comparison","text":""},{"location":"tutorials/basic-distance-computation.html#euclidean-distance","title":"Euclidean Distance","text":"<ul> <li>Fast and memory-efficient</li> <li>Good for initial exploration</li> <li>Works with any embedding</li> </ul> <pre><code>results = quick_distance(\n    data_dir=\"datasets\",\n    molecule_method=\"euclidean\"\n)\n</code></pre>"},{"location":"tutorials/basic-distance-computation.html#cosine-distance","title":"Cosine Distance","text":"<ul> <li>Focuses on feature orientation</li> <li>Good for high-dimensional embeddings</li> <li>Normalized by vector magnitude</li> </ul> <pre><code>results = quick_distance(\n    data_dir=\"datasets\",\n    molecule_method=\"cosine\"\n)\n</code></pre>"},{"location":"tutorials/basic-distance-computation.html#otdd-optimal-transport-dataset-distance","title":"OTDD (Optimal Transport Dataset Distance)","text":"<ul> <li>Most comprehensive but computationally expensive</li> <li>Considers both features and labels</li> <li>Best for detailed analysis</li> </ul> <pre><code>results = quick_distance(\n    data_dir=\"datasets\",\n    molecule_method=\"otdd\"\n)\n</code></pre>"},{"location":"tutorials/basic-distance-computation.html#featurizer-options","title":"Featurizer Options","text":"<p>Different molecular representations:</p> Featurizer Description Speed <code>ecfp</code> Extended Connectivity Fingerprints Fast <code>maccs</code> MACCS structural keys Fast <code>desc2D</code> 2D molecular descriptors Medium <code>desc3D</code> 3D molecular descriptors Slow <pre><code># Using different featurizers\nresults = quick_distance(\n    data_dir=\"datasets\",\n    molecule_featurizer=\"maccs\",  # or \"ecfp\", \"desc2D\"\n    molecule_method=\"euclidean\",\n)\n</code></pre>"},{"location":"tutorials/basic-distance-computation.html#using-config-files","title":"Using Config Files","text":"<p>For reproducible experiments:</p> <pre><code># config.yaml\ndata:\n  directory: \"datasets\"\n\nmolecule:\n  enabled: true\n  featurizer: \"ecfp\"\n  method: \"euclidean\"\n\noutput:\n  directory: \"output\"\n  format: \"csv\"\n  save_features: true\n</code></pre> <pre><code>from themap import run_pipeline\n\nresults = run_pipeline(\"config.yaml\")\n</code></pre>"},{"location":"tutorials/basic-distance-computation.html#analyzing-results","title":"Analyzing Results","text":""},{"location":"tutorials/basic-distance-computation.html#loading-distance-matrix","title":"Loading Distance Matrix","text":"<pre><code>import pandas as pd\n\ndistances = pd.read_csv(\"output/molecule_distances.csv\", index_col=0)\nprint(f\"Matrix shape: {distances.shape}\")\n</code></pre>"},{"location":"tutorials/basic-distance-computation.html#finding-most-similar-datasets","title":"Finding Most Similar Datasets","text":"<pre><code># Find closest source for each target\nfor target in distances.columns:\n    closest = distances[target].idxmin()\n    dist = distances[target].min()\n    print(f\"{target} &lt;- {closest} (distance: {dist:.4f})\")\n</code></pre>"},{"location":"tutorials/basic-distance-computation.html#task-hardness-estimation","title":"Task Hardness Estimation","text":"<pre><code># Estimate hardness as average distance to k-nearest sources\nk = 3\nfor target in distances.columns:\n    hardness = distances[target].nsmallest(k).mean()\n    print(f\"Hardness for {target}: {hardness:.4f}\")\n</code></pre>"},{"location":"tutorials/basic-distance-computation.html#distance-interpretation","title":"Distance Interpretation","text":"<ul> <li>0.0: Identical datasets</li> <li>Low values (&lt; 1.0): Very similar datasets</li> <li>Medium values (1.0-10.0): Moderately similar</li> <li>High values (&gt; 10.0): Very different datasets</li> </ul> <p>Note: Actual ranges depend on the distance method and data characteristics.</p>"},{"location":"tutorials/basic-distance-computation.html#performance-optimization","title":"Performance Optimization","text":""},{"location":"tutorials/basic-distance-computation.html#for-large-datasets","title":"For Large Datasets","text":"<pre><code># Use fast featurizer and method\nresults = quick_distance(\n    data_dir=\"datasets\",\n    molecule_featurizer=\"ecfp\",   # Fast fingerprints\n    molecule_method=\"euclidean\",  # Faster than OTDD\n    n_jobs=8,                     # Parallel processing\n)\n</code></pre>"},{"location":"tutorials/basic-distance-computation.html#caching-features","title":"Caching Features","text":"<pre><code># config.yaml\noutput:\n  save_features: true  # Cache features for reuse\n</code></pre>"},{"location":"tutorials/basic-distance-computation.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/basic-distance-computation.html#common-errors","title":"Common Errors","text":"<ol> <li>Memory Error: Use euclidean distance or reduce dataset size</li> <li>Import Error: Install required dependencies with <code>pip install -e \".[all]\"</code></li> <li>File Not Found: Check file paths and data structure</li> </ol>"},{"location":"tutorials/basic-distance-computation.html#performance-tips","title":"Performance Tips","text":"<ol> <li>Start with euclidean distance for exploration</li> <li>Use OTDD only for final analysis</li> <li>Enable feature caching for repeated computations</li> <li>Use parallel processing (<code>n_jobs</code> parameter)</li> </ol>"},{"location":"tutorials/basic-distance-computation.html#next-steps","title":"Next Steps","text":"<ul> <li>Learn about performance optimization</li> <li>Check out the examples</li> </ul>"},{"location":"tutorials/getting-started.html","title":"Getting Started Tutorial","text":"<p>This tutorial will walk you through the basic concepts and usage of THEMAP for task hardness estimation and distance computation.</p>"},{"location":"tutorials/getting-started.html#prerequisites","title":"Prerequisites","text":"<ul> <li>THEMAP installed with basic dependencies</li> <li>Python 3.10+</li> <li>Basic knowledge of molecular datasets</li> </ul>"},{"location":"tutorials/getting-started.html#tutorial-overview","title":"Tutorial Overview","text":"<p>In this tutorial, you will learn how to:</p> <ol> <li>Set up your data directory</li> <li>Compute distances between datasets</li> <li>Analyze the results</li> <li>Estimate task hardness</li> </ol>"},{"location":"tutorials/getting-started.html#step-1-setting-up-your-data","title":"Step 1: Setting Up Your Data","text":"<p>Organize your data in this structure:</p> <pre><code>datasets/\n\u251c\u2500\u2500 train/                        # Source datasets\n\u2502   \u251c\u2500\u2500 CHEMBL123456.jsonl.gz\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 test/                         # Target datasets\n    \u251c\u2500\u2500 CHEMBL111111.jsonl.gz\n    \u2514\u2500\u2500 ...\n</code></pre> <p>Each <code>.jsonl.gz</code> file contains molecules in JSON lines format: <pre><code>{\"SMILES\": \"CCO\", \"Property\": 1}\n{\"SMILES\": \"CCCO\", \"Property\": 0}\n</code></pre></p>"},{"location":"tutorials/getting-started.html#step-2-computing-distances-one-liner","title":"Step 2: Computing Distances (One-liner)","text":"<p>The simplest way to compute distances:</p> <pre><code>from themap import quick_distance\n\nresults = quick_distance(\n    data_dir=\"datasets\",\n    output_dir=\"output\",\n    molecule_featurizer=\"ecfp\",\n    molecule_method=\"euclidean\",\n)\n\nprint(\"Results saved to output/molecule_distances.csv\")\n</code></pre>"},{"location":"tutorials/getting-started.html#step-3-using-a-config-file","title":"Step 3: Using a Config File","text":"<p>For reproducible experiments:</p> <pre><code>from themap import run_pipeline\n\n# Create config file\nconfig_content = \"\"\"\ndata:\n  directory: \"datasets\"\n\nmolecule:\n  enabled: true\n  featurizer: \"ecfp\"\n  method: \"euclidean\"\n\noutput:\n  directory: \"output\"\n  format: \"csv\"\n\"\"\"\n\n# Save and run\nwith open(\"config.yaml\", \"w\") as f:\n    f.write(config_content)\n\nresults = run_pipeline(\"config.yaml\")\n</code></pre>"},{"location":"tutorials/getting-started.html#step-4-analyzing-results","title":"Step 4: Analyzing Results","text":"<pre><code>import pandas as pd\n\n# Load computed distances\ndistances = pd.read_csv(\"output/molecule_distances.csv\", index_col=0)\n\nprint(f\"Distance matrix shape: {distances.shape}\")\nprint(f\"Sources (rows): {list(distances.index)}\")\nprint(f\"Targets (columns): {list(distances.columns)}\")\n\n# Find closest source for each target\nfor target in distances.columns:\n    closest = distances[target].idxmin()\n    dist = distances[target].min()\n    print(f\"{target} &lt;- {closest} (distance: {dist:.4f})\")\n</code></pre>"},{"location":"tutorials/getting-started.html#step-5-estimating-task-hardness","title":"Step 5: Estimating Task Hardness","text":"<p>Task hardness is estimated from the average distance to the k-nearest source tasks:</p> <pre><code># Compute task hardness for each target\nk = 3\nfor target in distances.columns:\n    k_nearest = distances[target].nsmallest(k).mean()\n    print(f\"Task hardness for {target}: {k_nearest:.4f}\")\n</code></pre> <p>Higher hardness values indicate tasks that are more different from available training data.</p>"},{"location":"tutorials/getting-started.html#understanding-results","title":"Understanding Results","text":"<p>Distance values have the following interpretations:</p> <ul> <li>Lower values: More similar datasets (easier transfer learning)</li> <li>Higher values: More different datasets (harder transfer learning)</li> <li>Scale: Depends on the method and featurizer used</li> </ul>"},{"location":"tutorials/getting-started.html#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics:</p> <ol> <li>Try different distance methods (<code>cosine</code>, <code>otdd</code>)</li> <li>Try different featurizers (<code>maccs</code>, <code>desc2D</code>)</li> <li>Learn about performance optimization</li> <li>Check out the examples</li> </ol>"},{"location":"tutorials/getting-started.html#common-issues","title":"Common Issues","text":""},{"location":"tutorials/getting-started.html#import-errors","title":"Import Errors","text":"<p>Make sure all dependencies are installed: <pre><code>pip install -e \".[all]\"\n</code></pre></p>"},{"location":"tutorials/getting-started.html#memory-issues","title":"Memory Issues","text":"<p>Use euclidean distance for large datasets instead of OTDD.</p>"},{"location":"tutorials/getting-started.html#file-not-found","title":"File Not Found","text":"<p>Ensure your data files are in the correct directory structure.</p>"},{"location":"tutorials/performance-optimization.html","title":"Performance Optimization","text":"<p>This tutorial covers best practices for optimizing THEMAP performance when working with large datasets.</p>"},{"location":"tutorials/performance-optimization.html#overview","title":"Overview","text":"<p>THEMAP offers several strategies to optimize performance:</p> <ol> <li>Method selection: Choose appropriate distance metrics</li> <li>Featurizer selection: Choose fast vs. accurate featurizers</li> <li>Parallel processing: Use multiple cores</li> <li>Caching: Save features to disk for reuse</li> </ol>"},{"location":"tutorials/performance-optimization.html#distance-method-performance","title":"Distance Method Performance","text":""},{"location":"tutorials/performance-optimization.html#speed-comparison","title":"Speed Comparison","text":"Method Speed Memory Accuracy Best For Euclidean Fast Low Good Initial exploration, large datasets Cosine Fast Low Good High-dimensional features OTDD Slow High Best Detailed analysis, small datasets"},{"location":"tutorials/performance-optimization.html#choosing-the-right-method","title":"Choosing the Right Method","text":"<pre><code>from themap import quick_distance\n\n# For large datasets or initial exploration\nresults = quick_distance(\n    data_dir=\"datasets\",\n    molecule_method=\"euclidean\",  # Fast\n)\n\n# For final analysis on small datasets\nresults = quick_distance(\n    data_dir=\"datasets\",\n    molecule_method=\"otdd\",  # Most accurate but slow\n)\n</code></pre>"},{"location":"tutorials/performance-optimization.html#featurizer-performance","title":"Featurizer Performance","text":""},{"location":"tutorials/performance-optimization.html#speed-comparison_1","title":"Speed Comparison","text":"Featurizer Speed Quality <code>ecfp</code> Fast Good <code>maccs</code> Fast Good <code>desc2D</code> Medium Good <code>desc3D</code> Slow Better <pre><code># Fast featurizer for large datasets\nresults = quick_distance(\n    data_dir=\"datasets\",\n    molecule_featurizer=\"ecfp\",  # Fast fingerprints\n)\n</code></pre>"},{"location":"tutorials/performance-optimization.html#parallel-processing","title":"Parallel Processing","text":"<p>Use the <code>n_jobs</code> parameter:</p> <pre><code>from themap import quick_distance\n\nresults = quick_distance(\n    data_dir=\"datasets\",\n    n_jobs=8,  # Use 8 parallel workers\n)\n</code></pre>"},{"location":"tutorials/performance-optimization.html#caching-features","title":"Caching Features","text":"<p>Save computed features to disk for reuse:</p> <pre><code># config.yaml\noutput:\n  save_features: true  # Cache features for reuse\n</code></pre> <pre><code>from themap import run_pipeline\n\n# First run: computes and caches features\nresults = run_pipeline(\"config.yaml\")\n\n# Subsequent runs: loads cached features (faster)\nresults = run_pipeline(\"config.yaml\")\n</code></pre>"},{"location":"tutorials/performance-optimization.html#memory-management","title":"Memory Management","text":"<p>For large datasets:</p> <pre><code>from themap import quick_distance\n\n# Use euclidean instead of OTDD (much less memory)\nresults = quick_distance(\n    data_dir=\"datasets\",\n    molecule_featurizer=\"ecfp\",\n    molecule_method=\"euclidean\",\n)\n</code></pre>"},{"location":"tutorials/performance-optimization.html#best-practices","title":"Best Practices","text":""},{"location":"tutorials/performance-optimization.html#quick-optimization-checklist","title":"Quick Optimization Checklist","text":"<ol> <li>Start with fast methods: Use euclidean for exploration</li> <li>Use fast featurizers: ecfp or maccs for initial runs</li> <li>Enable caching: Set <code>save_features: true</code></li> <li>Use parallel processing: Set <code>n_jobs</code> to available cores</li> <li>Reserve OTDD for final analysis: Only use on small datasets</li> </ol>"},{"location":"tutorials/performance-optimization.html#recommended-configuration","title":"Recommended Configuration","text":"<pre><code># config.yaml - optimized for performance\ndata:\n  directory: \"datasets\"\n\nmolecule:\n  enabled: true\n  featurizer: \"ecfp\"      # Fast fingerprints\n  method: \"euclidean\"     # Fast distance\n\noutput:\n  directory: \"output\"\n  format: \"csv\"\n  save_features: true     # Cache for reuse\n\ncompute:\n  n_jobs: 8               # Parallel processing\n  device: \"auto\"          # Use GPU if available\n</code></pre>"},{"location":"tutorials/performance-optimization.html#benchmarking","title":"Benchmarking","text":"<p>Compare methods on your data:</p> <pre><code>import time\nfrom themap import quick_distance\n\nmethods = [\"euclidean\", \"cosine\"]\n\nfor method in methods:\n    start = time.time()\n    results = quick_distance(\n        data_dir=\"datasets\",\n        molecule_method=method,\n    )\n    elapsed = time.time() - start\n    print(f\"{method}: {elapsed:.2f}s\")\n</code></pre>"},{"location":"tutorials/performance-optimization.html#next-steps","title":"Next Steps","text":"<ul> <li>Check out the examples</li> <li>Read the API documentation</li> </ul>"},{"location":"tutorials/working-with-tasks.html","title":"Working with Tasks","text":"<p>This tutorial covers THEMAP's unified task system that integrates molecular data, protein data, and metadata for comprehensive analysis.</p>"},{"location":"tutorials/working-with-tasks.html#understanding-the-task-system","title":"Understanding the Task System","text":"<p>The Task system in THEMAP provides a unified interface for working with multi-modal bioactivity prediction data:</p> <ul> <li>Tasks: Individual prediction problems (e.g., CHEMBL1023359)</li> <li>Data modalities: Molecules, proteins, metadata</li> <li>Splits: Train/test/validation divisions</li> <li>Caching: Efficient feature storage and retrieval</li> </ul>"},{"location":"tutorials/working-with-tasks.html#loading-tasks","title":"Loading Tasks","text":""},{"location":"tutorials/working-with-tasks.html#basic-task-loading","title":"Basic Task Loading","text":"<pre><code>from themap.data.tasks import Tasks\n\n# Load tasks from a directory structure\ntasks = Tasks.from_directory(\n    directory=\"datasets/\",\n    task_list_file=\"datasets/sample_tasks_list.json\",\n    load_molecules=True,\n    load_proteins=True,\n    load_metadata=True,\n    cache_dir=\"cache/\"\n)\n\nprint(f\"Loaded {len(tasks)} tasks\")\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#task-configuration-file","title":"Task Configuration File","text":"<p>The <code>sample_tasks_list.json</code> file defines which tasks belong to which split:</p> <pre><code>{\n  \"train\": [\"CHEMBL1023359\", \"CHEMBL1613776\", \"CHEMBL4078627\"],\n  \"test\": [\"CHEMBL2219358\", \"CHEMBL1963831\"],\n  \"valid\": [\"CHEMBL2219236\"]\n}\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#directory-structure","title":"Directory Structure","text":"<pre><code>datasets/\n\u251c\u2500\u2500 train/\n\u2502   \u251c\u2500\u2500 CHEMBL1023359.jsonl.gz    # Molecular data\n\u2502   \u251c\u2500\u2500 CHEMBL1023359.fasta       # Protein sequences\n\u2502   \u2514\u2500\u2500 CHEMBL1023359_metadata.json\n\u251c\u2500\u2500 test/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 valid/\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 sample_tasks_list.json\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#exploring-tasks","title":"Exploring Tasks","text":""},{"location":"tutorials/working-with-tasks.html#basic-task-information","title":"Basic Task Information","text":"<pre><code># Get task statistics\nprint(f\"Total tasks: {len(tasks)}\")\nprint(f\"Train tasks: {tasks.get_num_fold_tasks('TRAIN')}\")\nprint(f\"Test tasks: {tasks.get_num_fold_tasks('TEST')}\")\nprint(f\"Valid tasks: {tasks.get_num_fold_tasks('VALID')}\")\n\n# Get task IDs\ntrain_task_ids = tasks.get_task_ids(fold='TRAIN')\nprint(f\"Training task IDs: {train_task_ids}\")\n\n# Access individual tasks\ntask = tasks.get_task(\"CHEMBL1023359\")\nprint(f\"Task {task.task_id} has {len(task.molecules)} molecules\")\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#data-modality-access","title":"Data Modality Access","text":"<pre><code># Access different data types\nfor task_id in tasks.get_task_ids()[:3]:  # First 3 tasks\n    task = tasks.get_task(task_id)\n\n    print(f\"\\nTask: {task_id}\")\n\n    # Molecular data\n    if hasattr(task, 'molecules') and task.molecules:\n        print(f\"  Molecules: {len(task.molecules)}\")\n        print(f\"  Sample SMILES: {task.molecules[0].smiles}\")\n\n    # Protein data\n    if hasattr(task, 'proteins') and task.proteins:\n        print(f\"  Proteins: {len(task.proteins)}\")\n        print(f\"  Sample protein length: {len(task.proteins[0].sequence)}\")\n\n    # Metadata\n    if hasattr(task, 'metadata') and task.metadata:\n        print(f\"  Metadata keys: {list(task.metadata.keys())}\")\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#task-based-distance-computation","title":"Task-Based Distance Computation","text":""},{"location":"tutorials/working-with-tasks.html#unified-distance-calculation","title":"Unified Distance Calculation","text":"<pre><code>from themap.distance import TaskDistance\n\n# Create task distance calculator\ntask_distance = TaskDistance(\n    tasks=tasks,\n    molecule_method=\"cosine\",\n    protein_method=\"euclidean\"\n)\n\n# Compute all distance types\nall_distances = task_distance.compute_all_distances(\n    combination_strategy=\"weighted_average\",\n    molecule_weight=0.7,\n    protein_weight=0.3\n)\n\nprint(\"Distance types computed:\")\nprint(f\"  Molecule distances: {len(all_distances['molecule'])} tasks\")\nprint(f\"  Protein distances: {len(all_distances['protein'])} tasks\")\nprint(f\"  Combined distances: {len(all_distances['combined'])} tasks\")\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#specific-distance-types","title":"Specific Distance Types","text":"<pre><code># Compute only molecular distances\nmolecule_distances = task_distance.get_molecule_distances()\n\n# Compute only protein distances\nprotein_distances = task_distance.get_protein_distances()\n\n# Compute combined distances with custom weights\ncombined_distances = task_distance.get_combined_distances(\n    molecule_weight=0.6,\n    protein_weight=0.4\n)\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#working-with-folds","title":"Working with Folds","text":""},{"location":"tutorials/working-with-tasks.html#train-test-analysis","title":"Train-Test Analysis","text":"<pre><code>def analyze_train_test_distances(tasks, distance_type=\"molecule\"):\n    \"\"\"Analyze distances between train and test tasks.\"\"\"\n\n    # Get task IDs by fold\n    train_ids = set(tasks.get_task_ids(fold='TRAIN'))\n    test_ids = set(tasks.get_task_ids(fold='TEST'))\n\n    # Compute distances\n    task_distance = TaskDistance(tasks=tasks)\n    distances = task_distance.compute_all_distances()[distance_type]\n\n    # Extract train-test distances\n    train_test_distances = []\n\n    for test_id in test_ids:\n        if test_id in distances:\n            for train_id in train_ids:\n                if train_id in distances[test_id]:\n                    train_test_distances.append({\n                        'test_task': test_id,\n                        'train_task': train_id,\n                        'distance': distances[test_id][train_id]\n                    })\n\n    return train_test_distances\n\n# Analyze train-test relationships\ntt_distances = analyze_train_test_distances(tasks, \"molecule\")\nprint(f\"Found {len(tt_distances)} train-test pairs\")\n\n# Find closest training tasks for each test task\nimport pandas as pd\n\ndf = pd.DataFrame(tt_distances)\nfor test_task in df['test_task'].unique():\n    task_distances = df[df['test_task'] == test_task]\n    closest = task_distances.nsmallest(3, 'distance')\n\n    print(f\"\\nTest task {test_task} - closest training tasks:\")\n    for _, row in closest.iterrows():\n        print(f\"  {row['train_task']}: {row['distance']:.3f}\")\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#cross-validation-support","title":"Cross-Validation Support","text":"<pre><code>def create_cv_folds(tasks, n_folds=5):\n    \"\"\"Create cross-validation folds from tasks.\"\"\"\n\n    all_task_ids = tasks.get_task_ids()\n    random.shuffle(all_task_ids)  # Randomize\n\n    fold_size = len(all_task_ids) // n_folds\n    folds = []\n\n    for i in range(n_folds):\n        start_idx = i * fold_size\n        end_idx = start_idx + fold_size if i &lt; n_folds - 1 else len(all_task_ids)\n\n        test_tasks = all_task_ids[start_idx:end_idx]\n        train_tasks = [tid for tid in all_task_ids if tid not in test_tasks]\n\n        folds.append({\n            'fold': i,\n            'train': train_tasks,\n            'test': test_tasks\n        })\n\n    return folds\n\n# Create CV folds\ncv_folds = create_cv_folds(tasks, n_folds=5)\nprint(f\"Created {len(cv_folds)} CV folds\")\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#caching-and-performance","title":"Caching and Performance","text":""},{"location":"tutorials/working-with-tasks.html#feature-caching","title":"Feature Caching","text":"<pre><code># Tasks automatically cache computed features\ntasks_with_cache = Tasks.from_directory(\n    directory=\"datasets/\",\n    task_list_file=\"datasets/sample_tasks_list.json\",\n    load_molecules=True,\n    load_proteins=True,\n    cache_dir=\"cache/\",  # Features will be cached here\n    force_reload=False   # Use cached features if available\n)\n\n# Check cache status\nprint(f\"Cache directory: {tasks_with_cache.cache_dir}\")\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#selective-loading","title":"Selective Loading","text":"<pre><code># Load only specific data types for better performance\nmolecule_only_tasks = Tasks.from_directory(\n    directory=\"datasets/\",\n    task_list_file=\"datasets/sample_tasks_list.json\",\n    load_molecules=True,\n    load_proteins=False,  # Skip protein loading\n    load_metadata=False   # Skip metadata loading\n)\n\nprint(\"Loaded molecular data only for faster processing\")\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#advanced-task-operations","title":"Advanced Task Operations","text":""},{"location":"tutorials/working-with-tasks.html#task-filtering","title":"Task Filtering","text":"<pre><code>def filter_tasks_by_size(tasks, min_molecules=10, max_molecules=1000):\n    \"\"\"Filter tasks by number of molecules.\"\"\"\n\n    filtered_task_ids = []\n\n    for task_id in tasks.get_task_ids():\n        task = tasks.get_task(task_id)\n        if hasattr(task, 'molecules') and task.molecules:\n            n_molecules = len(task.molecules)\n            if min_molecules &lt;= n_molecules &lt;= max_molecules:\n                filtered_task_ids.append(task_id)\n\n    return filtered_task_ids\n\n# Filter tasks\ngood_tasks = filter_tasks_by_size(tasks, min_molecules=20, max_molecules=500)\nprint(f\"Found {len(good_tasks)} tasks with appropriate size\")\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#task-metadata-analysis","title":"Task Metadata Analysis","text":"<pre><code>def analyze_task_metadata(tasks):\n    \"\"\"Analyze metadata across all tasks.\"\"\"\n\n    metadata_summary = {}\n\n    for task_id in tasks.get_task_ids():\n        task = tasks.get_task(task_id)\n\n        if hasattr(task, 'metadata') and task.metadata:\n            for key, value in task.metadata.items():\n                if key not in metadata_summary:\n                    metadata_summary[key] = []\n                metadata_summary[key].append(value)\n\n    # Print summary\n    for key, values in metadata_summary.items():\n        unique_values = len(set(str(v) for v in values))\n        print(f\"Metadata '{key}': {len(values)} tasks, {unique_values} unique values\")\n\n    return metadata_summary\n\n# Analyze metadata\nmetadata = analyze_task_metadata(tasks)\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#integration-with-external-tools","title":"Integration with External Tools","text":""},{"location":"tutorials/working-with-tasks.html#export-for-analysis","title":"Export for Analysis","text":"<pre><code>def export_task_summary(tasks, output_file=\"task_summary.csv\"):\n    \"\"\"Export task information to CSV for external analysis.\"\"\"\n\n    import pandas as pd\n\n    summary_data = []\n\n    for task_id in tasks.get_task_ids():\n        task = tasks.get_task(task_id)\n\n        row = {'task_id': task_id}\n\n        # Add molecule info\n        if hasattr(task, 'molecules') and task.molecules:\n            row['n_molecules'] = len(task.molecules)\n        else:\n            row['n_molecules'] = 0\n\n        # Add protein info\n        if hasattr(task, 'proteins') and task.proteins:\n            row['n_proteins'] = len(task.proteins)\n            row['avg_protein_length'] = sum(len(p.sequence) for p in task.proteins) / len(task.proteins)\n        else:\n            row['n_proteins'] = 0\n            row['avg_protein_length'] = 0\n\n        # Add metadata\n        if hasattr(task, 'metadata') and task.metadata:\n            for key, value in task.metadata.items():\n                row[f'metadata_{key}'] = value\n\n        summary_data.append(row)\n\n    df = pd.DataFrame(summary_data)\n    df.to_csv(output_file, index=False)\n    print(f\"Task summary exported to {output_file}\")\n\n    return df\n\n# Export summary\ntask_df = export_task_summary(tasks)\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#best-practices","title":"Best Practices","text":""},{"location":"tutorials/working-with-tasks.html#performance-tips","title":"Performance Tips","text":"<ol> <li>Use caching: Always specify a cache directory</li> <li>Load selectively: Only load needed data types</li> <li>Filter early: Remove unsuitable tasks before distance computation</li> <li>Batch processing: Process tasks in groups for large datasets</li> </ol>"},{"location":"tutorials/working-with-tasks.html#memory-management","title":"Memory Management","text":"<pre><code># For large task sets, process in batches\ndef process_tasks_in_batches(tasks, batch_size=10):\n    \"\"\"Process tasks in smaller batches to manage memory.\"\"\"\n\n    task_ids = tasks.get_task_ids()\n\n    for i in range(0, len(task_ids), batch_size):\n        batch_ids = task_ids[i:i + batch_size]\n\n        # Create subset tasks\n        batch_tasks = Tasks()\n        for task_id in batch_ids:\n            batch_tasks.add_task(tasks.get_task(task_id))\n\n        # Process batch\n        yield batch_tasks\n\n# Example usage\nfor batch_tasks in process_tasks_in_batches(tasks, batch_size=5):\n    print(f\"Processing batch with {len(batch_tasks)} tasks\")\n    # Perform distance computation on batch\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/working-with-tasks.html#common-issues","title":"Common Issues","text":"<ol> <li>Missing files: Ensure all task files exist in expected directories</li> <li>Cache conflicts: Use <code>force_reload=True</code> to refresh cached features</li> <li>Memory errors: Reduce batch size or load fewer data modalities</li> <li>Inconsistent data: Validate that all tasks have required data types</li> </ol>"},{"location":"tutorials/working-with-tasks.html#validation","title":"Validation","text":"<pre><code>def validate_tasks(tasks):\n    \"\"\"Validate task data consistency.\"\"\"\n\n    issues = []\n\n    for task_id in tasks.get_task_ids():\n        task = tasks.get_task(task_id)\n\n        # Check for required data\n        if not hasattr(task, 'molecules') or not task.molecules:\n            issues.append(f\"Task {task_id}: No molecular data\")\n\n        if not hasattr(task, 'proteins') or not task.proteins:\n            issues.append(f\"Task {task_id}: No protein data\")\n\n    if issues:\n        print(\"Validation issues found:\")\n        for issue in issues:\n            print(f\"  - {issue}\")\n    else:\n        print(\"All tasks validated successfully\")\n\n    return issues\n\n# Validate loaded tasks\nvalidation_issues = validate_tasks(tasks)\n</code></pre>"},{"location":"tutorials/working-with-tasks.html#next-steps","title":"Next Steps","text":"<ul> <li>Explore performance optimization</li> <li>Learn about task hardness estimation</li> <li>Try advanced distance combination strategies</li> <li>Integrate with your machine learning pipeline</li> </ul>"},{"location":"user-guide/cli.html","title":"Command Line Interface","text":"<p>THEMAP provides a powerful command-line interface for running distance computations without writing Python code. This guide covers all available commands and their options.</p>"},{"location":"user-guide/cli.html#installation","title":"Installation","text":"<p>The CLI is automatically installed when you install THEMAP:</p> <pre><code>pip install -e .\n</code></pre> <p>Verify the installation:</p> <pre><code>themap --help\n</code></pre>"},{"location":"user-guide/cli.html#commands-overview","title":"Commands Overview","text":"Command Description <code>themap run</code> Run pipeline with a YAML configuration file <code>themap quick</code> Quick distance computation with minimal configuration <code>themap init</code> Create a sample configuration file <code>themap convert</code> Convert CSV files to JSONL.GZ format <code>themap info</code> Show information about a dataset directory <code>themap list-featurizers</code> List available molecule and protein featurizers"},{"location":"user-guide/cli.html#quick-distance-computation","title":"Quick Distance Computation","text":"<p>The fastest way to compute distances:</p> <pre><code>themap quick datasets/\n</code></pre>"},{"location":"user-guide/cli.html#options","title":"Options","text":"<pre><code>themap quick [OPTIONS] DATA_DIR\n\nOptions:\n  -o, --output TEXT      Output directory (default: output)\n  -f, --featurizer TEXT  Molecule featurizer (default: ecfp)\n  -m, --method TEXT      Distance method (default: euclidean)\n  -j, --n-jobs INTEGER   Number of parallel jobs (default: 8)\n</code></pre>"},{"location":"user-guide/cli.html#examples","title":"Examples","text":"<pre><code># Basic usage with defaults\nthemap quick datasets/\n\n# Custom featurizer and method\nthemap quick datasets/ --featurizer maccs --method cosine\n\n# Specify output directory\nthemap quick datasets/ --output results/my_experiment\n\n# Use more parallel workers\nthemap quick datasets/ --n-jobs 16\n</code></pre>"},{"location":"user-guide/cli.html#run-pipeline-with-configuration","title":"Run Pipeline with Configuration","text":"<p>For reproducible experiments, use a YAML configuration file:</p> <pre><code>themap run config.yaml\n</code></pre>"},{"location":"user-guide/cli.html#options_1","title":"Options","text":"<pre><code>themap run [OPTIONS] CONFIG\n\nArguments:\n  CONFIG  Path to YAML configuration file (required)\n\nOptions:\n  -o, --output PATH      Output directory (overrides config)\n  --molecule-only        Only compute molecule distances\n  --protein-only         Only compute protein distances\n  -j, --n-jobs INTEGER   Number of parallel jobs\n  -v, --verbose          Enable verbose output\n</code></pre>"},{"location":"user-guide/cli.html#examples_1","title":"Examples","text":"<pre><code># Run with config file\nthemap run config.yaml\n\n# Override output directory\nthemap run config.yaml --output results/experiment_01\n\n# Only compute molecular distances\nthemap run config.yaml --molecule-only\n\n# Verbose output for debugging\nthemap run config.yaml --verbose\n</code></pre>"},{"location":"user-guide/cli.html#initialize-configuration","title":"Initialize Configuration","text":"<p>Create a sample configuration file to get started:</p> <pre><code>themap init\n</code></pre>"},{"location":"user-guide/cli.html#options_2","title":"Options","text":"<pre><code>themap init [OPTIONS]\n\nOptions:\n  -o, --output TEXT      Output file path (default: config.yaml)\n  --data-dir PATH        Data directory to use in config\n</code></pre>"},{"location":"user-guide/cli.html#examples_2","title":"Examples","text":"<pre><code># Create default config.yaml\nthemap init\n\n# Create config with custom name\nthemap init --output my_config.yaml\n\n# Create config pointing to specific data directory\nthemap init --data-dir /path/to/datasets\n</code></pre>"},{"location":"user-guide/cli.html#generated-configuration","title":"Generated Configuration","text":"<p>The generated configuration file looks like:</p> <pre><code>data:\n  directory: \"datasets\"\n  task_list: null  # Auto-discover all files\n\nmolecule:\n  enabled: true\n  featurizer: \"ecfp\"\n  method: \"euclidean\"\n\nprotein:\n  enabled: false\n\noutput:\n  directory: \"output\"\n  format: \"csv\"\n  save_features: true\n\ncompute:\n  n_jobs: 8\n  device: \"auto\"\n</code></pre>"},{"location":"user-guide/cli.html#convert-csv-to-jsonlgz","title":"Convert CSV to JSONL.GZ","text":"<p>Convert CSV files to THEMAP's native JSONL.GZ format:</p> <pre><code>themap convert data.csv CHEMBL123456\n</code></pre>"},{"location":"user-guide/cli.html#options_3","title":"Options","text":"<pre><code>themap convert [OPTIONS] INPUT_CSV TASK_ID\n\nArguments:\n  INPUT_CSV  Path to the CSV file (required)\n  TASK_ID    Task identifier, e.g., CHEMBL123456 (required)\n\nOptions:\n  -o, --output PATH          Output file path\n  --smiles-column TEXT       SMILES column name (auto-detected if not specified)\n  --activity-column TEXT     Activity column name (auto-detected if not specified)\n  --no-validate              Skip SMILES validation\n</code></pre>"},{"location":"user-guide/cli.html#examples_3","title":"Examples","text":"<pre><code># Basic conversion (auto-detect columns)\nthemap convert data.csv CHEMBL123456\n\n# Specify output path\nthemap convert data.csv CHEMBL123456 --output datasets/train/CHEMBL123456.jsonl.gz\n\n# Specify column names\nthemap convert data.csv CHEMBL123456 --smiles-column SMILES --activity-column pIC50\n\n# Skip SMILES validation (faster but less safe)\nthemap convert data.csv CHEMBL123456 --no-validate\n</code></pre>"},{"location":"user-guide/cli.html#expected-csv-format","title":"Expected CSV Format","text":"<p>The CSV file should have at minimum:</p> <ul> <li>A SMILES column (auto-detected names: <code>SMILES</code>, <code>smiles</code>, <code>Smiles</code>, <code>canonical_smiles</code>)</li> <li>An activity column (auto-detected names: <code>Property</code>, <code>Activity</code>, <code>pIC50</code>, <code>Label</code>)</li> </ul> <pre><code>SMILES,Property\nCCO,1\nCCCO,0\nCC(=O)O,1\n</code></pre>"},{"location":"user-guide/cli.html#dataset-information","title":"Dataset Information","text":"<p>Show information about a dataset directory:</p> <pre><code>themap info datasets/\n</code></pre>"},{"location":"user-guide/cli.html#output","title":"Output","text":"<pre><code>Dataset Directory: /path/to/datasets\nTask list provided: True\n\nFolds:\n  train:\n    Tasks: 10\n    CSV files: 0\n    JSONL.GZ files: 10\n  test:\n    Tasks: 3\n    CSV files: 0\n    JSONL.GZ files: 3\n\nProteins: 13 FASTA files\n</code></pre>"},{"location":"user-guide/cli.html#list-available-featurizers","title":"List Available Featurizers","text":"<p>View all available molecule and protein featurizers:</p> <pre><code>themap list-featurizers\n</code></pre>"},{"location":"user-guide/cli.html#output_1","title":"Output","text":"<pre><code>Molecule Featurizers:\n\n  Fingerprints (fast):\n    - ecfp\n    - maccs\n    - topological\n    - avalon\n\n  Descriptors (medium):\n    - desc2D\n    - mordred\n\n  Neural Embeddings (slow, requires GPU):\n    - ChemBERTa-77M-MLM\n    - ChemBERTa-77M-MTR\n    - MolT5\n    - Roberta-Zinc480M-102M\n\n\nProtein Featurizers:\n\n  ESM2 Models:\n    - esm2_t6_8M_UR50D\n    - esm2_t12_35M_UR50D\n    - esm2_t30_150M_UR50D\n    - esm2_t33_650M_UR50D\n\n  ESM3 Models:\n    - esm3_sm_open_v1\n</code></pre>"},{"location":"user-guide/cli.html#global-options","title":"Global Options","text":"<p>All commands support these global options:</p> <pre><code>themap [OPTIONS] COMMAND\n\nOptions:\n  -v, --verbose  Enable verbose output\n  --help         Show help message\n</code></pre>"},{"location":"user-guide/cli.html#environment-variables","title":"Environment Variables","text":"<p>THEMAP respects these environment variables:</p> Variable Description Default <code>THEMAP_DATA_DIR</code> Default data directory <code>datasets/</code> <code>THEMAP_CACHE_DIR</code> Feature cache directory <code>cache/</code> <code>CUDA_VISIBLE_DEVICES</code> GPU devices for neural featurizers All GPUs"},{"location":"user-guide/cli.html#workflow-examples","title":"Workflow Examples","text":""},{"location":"user-guide/cli.html#complete-workflow","title":"Complete Workflow","text":"<pre><code># 1. Check available featurizers\nthemap list-featurizers\n\n# 2. Initialize configuration\nthemap init --output my_experiment.yaml --data-dir datasets/TDC\n\n# 3. Edit the configuration file as needed\n# (use your favorite editor)\n\n# 4. Validate your data\nthemap info datasets/TDC\n\n# 5. Run the pipeline\nthemap run my_experiment.yaml --verbose\n\n# 6. Results are saved to output directory\n</code></pre>"},{"location":"user-guide/cli.html#converting-external-data","title":"Converting External Data","text":"<pre><code># 1. Convert multiple CSV files\nfor csv in raw_data/*.csv; do\n    task_id=$(basename \"$csv\" .csv)\n    themap convert \"$csv\" \"$task_id\" --output datasets/train/\"$task_id\".jsonl.gz\ndone\n\n# 2. Verify the conversion\nthemap info datasets/\n\n# 3. Run distance computation\nthemap quick datasets/ --output results/\n</code></pre>"},{"location":"user-guide/cli.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/cli.html#common-issues","title":"Common Issues","text":"<p>Command not found: <pre><code># Ensure THEMAP is installed\npip install -e .\n\n# Or use python -m\npython -m themap.cli --help\n</code></pre></p> <p>Missing dependencies: <pre><code># Install all optional dependencies\npip install -e \".[all]\"\n</code></pre></p> <p>Memory errors: <pre><code># Use faster methods for large datasets\nthemap quick datasets/ --method euclidean --featurizer ecfp\n</code></pre></p> <p>GPU not detected: <pre><code># Check CUDA availability\npython -c \"import torch; print(torch.cuda.is_available())\"\n\n# Force CPU usage\nCUDA_VISIBLE_DEVICES=\"\" themap run config.yaml\n</code></pre></p>"},{"location":"user-guide/cli.html#next-steps","title":"Next Steps","text":"<ul> <li>Learn about distance computation</li> <li>Explore the Python API</li> <li>Check out examples</li> </ul>"},{"location":"user-guide/distance-computation.html","title":"Distance Computation Guide","text":"<p>This guide provides comprehensive information about computing distances between datasets, tasks, and molecular/protein spaces in THEMAP.</p>"},{"location":"user-guide/distance-computation.html#overview","title":"Overview","text":"<p>Distance computation is central to THEMAP's functionality, enabling:</p> <ul> <li>Dataset similarity assessment: Compare chemical spaces between datasets</li> <li>Transfer learning guidance: Identify similar tasks for knowledge transfer</li> <li>Task hardness estimation: Quantify prediction difficulty</li> <li>Multi-modal analysis: Combine molecular, protein, and metadata information</li> </ul>"},{"location":"user-guide/distance-computation.html#distance-types","title":"Distance Types","text":""},{"location":"user-guide/distance-computation.html#1-molecular-dataset-distances","title":"1. Molecular Dataset Distances","text":""},{"location":"user-guide/distance-computation.html#otdd-optimal-transport-dataset-distance","title":"OTDD (Optimal Transport Dataset Distance)","text":"<p>OTDD provides the most comprehensive comparison by considering both feature distributions and label relationships.</p> <pre><code>from themap.distance import MoleculeDatasetDistance\n\n# Initialize with OTDD\nmol_distance = MoleculeDatasetDistance(\n    tasks=tasks,\n    molecule_method=\"otdd\"\n)\n\n# Compute distances\ndistances = mol_distance.get_distance()\n</code></pre> <p>When to use OTDD: - \u2705 High accuracy requirements - \u2705 Moderate dataset sizes (&lt; 10,000 molecules) - \u2705 Both features and labels are important - \u274c Large-scale computations (memory intensive)</p> <p>Configuration options: <pre><code># Customize OTDD parameters\nhopts = mol_distance.get_hopts(\"molecule\")\nprint(hopts)\n# {'maxsamples': 1000, 'device': 'auto', ...}\n\n# Modify parameters through configuration file\n# themap/models/distance_configures/otdd.json\n</code></pre></p>"},{"location":"user-guide/distance-computation.html#euclidean-distance","title":"Euclidean Distance","text":"<p>Fast and interpretable distance based on feature vector similarity.</p> <pre><code>mol_distance = MoleculeDatasetDistance(\n    tasks=tasks,\n    molecule_method=\"euclidean\"\n)\n\ndistances = mol_distance.get_distance()\n</code></pre> <p>When to use Euclidean: - \u2705 Large datasets (&gt; 10,000 molecules) - \u2705 Fast computation requirements - \u2705 Feature magnitude is important - \u274c High-dimensional sparse features</p>"},{"location":"user-guide/distance-computation.html#cosine-distance","title":"Cosine Distance","text":"<p>Measures angular similarity, good for high-dimensional feature spaces.</p> <pre><code>mol_distance = MoleculeDatasetDistance(\n    tasks=tasks,\n    molecule_method=\"cosine\"\n)\n\ndistances = mol_distance.get_distance()\n</code></pre> <p>When to use Cosine: - \u2705 High-dimensional features - \u2705 Sparse feature vectors - \u2705 Feature orientation matters more than magnitude - \u274c When magnitude differences are important</p>"},{"location":"user-guide/distance-computation.html#2-protein-dataset-distances","title":"2. Protein Dataset Distances","text":"<p>Protein distances focus on sequence and structural similarity.</p> <pre><code>from themap.distance import ProteinDatasetDistance\n\n# Euclidean distance for protein features\nprot_distance = ProteinDatasetDistance(\n    tasks=tasks,\n    protein_method=\"euclidean\"\n)\n\ndistances = prot_distance.get_distance()\n</code></pre> <p>Available methods: - <code>\"euclidean\"</code>: Standard L2 distance - <code>\"cosine\"</code>: Angular similarity - <code>\"sequence_identity\"</code>: (Future) Direct sequence comparison</p>"},{"location":"user-guide/distance-computation.html#3-combined-task-distances","title":"3. Combined Task Distances","text":"<p>Integrate multiple data modalities for comprehensive task comparison.</p> <pre><code>from themap.distance import TaskDistance\n\n# Initialize with multiple methods\ntask_distance = TaskDistance(\n    tasks=tasks,\n    molecule_method=\"cosine\",\n    protein_method=\"euclidean\",\n    metadata_method=\"jaccard\"\n)\n\n# Compute all distance types\nall_distances = task_distance.compute_all_distances(\n    combination_strategy=\"weighted_average\",\n    molecule_weight=0.5,\n    protein_weight=0.3,\n    metadata_weight=0.2\n)\n</code></pre> <p>Combination strategies:</p> Strategy Description Use Case <code>\"average\"</code> Simple arithmetic mean Equal importance of modalities <code>\"weighted_average\"</code> Weighted combination Different modality importance <code>\"min\"</code> Minimum distance Conservative similarity <code>\"max\"</code> Maximum distance Liberal dissimilarity"},{"location":"user-guide/distance-computation.html#working-with-features","title":"Working with Features","text":""},{"location":"user-guide/distance-computation.html#feature-computation","title":"Feature Computation","text":"<p>THEMAP provides unified feature extraction across data modalities:</p> <pre><code># Molecular features\nmol_features = tasks.compute_all_task_features(\n    molecule_featurizer=\"ecfp\",\n    combination_method=\"concatenate\",\n    folds=[\"TRAIN\", \"TEST\"]\n)\n\n# Protein features\nprot_features = tasks.compute_all_task_features(\n    protein_featurizer=\"esm2_t33_650M_UR50D\",\n    combination_method=\"concatenate\"\n)\n\n# Combined multi-modal features\ncombined_features = tasks.compute_all_task_features(\n    molecule_featurizer=\"morgan\",\n    protein_featurizer=\"esm2_t33_650M_UR50D\",\n    metadata_configs={\n        \"assay_description\": {\"featurizer_name\": \"sentence-transformers\"},\n        \"bioactivity\": {\"featurizer_name\": \"standardize\"}\n    },\n    combination_method=\"concatenate\"\n)\n</code></pre>"},{"location":"user-guide/distance-computation.html#feature-caching","title":"Feature Caching","text":"<p>Expensive feature computations can be cached for reuse:</p> <pre><code># Save computed features\ntasks.save_task_features_to_file(\n    output_path=\"cache/task_features.pkl\",\n    molecule_featurizer=\"ecfp\",\n    protein_featurizer=\"esm2_t33_650M_UR50D\"\n)\n\n# Load cached features\ncached_features = Tasks.load_task_features_from_file(\"cache/task_features.pkl\")\n</code></pre>"},{"location":"user-guide/distance-computation.html#distance-matrix-organization","title":"Distance Matrix Organization","text":"<p>THEMAP organizes distance computations for N\u00d7M comparisons:</p> <pre><code># Get features ready for distance computation\nsource_features, target_features, source_names, target_names = (\n    tasks.get_distance_computation_ready_features(\n        molecule_featurizer=\"ecfp\",\n        protein_featurizer=\"esm2_t33_650M_UR50D\",\n        combination_method=\"concatenate\",\n        source_fold=\"TRAIN\",      # N source tasks\n        target_folds=[\"TEST\"]     # M target tasks\n    )\n)\n\nprint(f\"Computing {len(source_features)}\u00d7{len(target_features)} distance matrix\")\n</code></pre>"},{"location":"user-guide/distance-computation.html#external-distance-matrices","title":"External Distance Matrices","text":"<p>Work with pre-computed distance matrices from external sources:</p>"},{"location":"user-guide/distance-computation.html#loading-external-matrices","title":"Loading External Matrices","text":"<pre><code># Load chemical space distances\nchem_distances = TaskDistance.load_ext_chem_distance(\"external_chem_dist.pkl\")\n\n# Load protein space distances\nprot_distances = TaskDistance.load_ext_prot_distance(\"external_prot_dist.pkl\")\n\n# Initialize with external matrices\nimport numpy as np\n\nexternal_matrix = np.random.rand(10, 8)  # 10 source \u00d7 8 target\ntask_distance = TaskDistance(\n    tasks=None,\n    source_task_ids=[\"train_1\", \"train_2\", ...],\n    target_task_ids=[\"test_1\", \"test_2\", ...],\n    external_chemical_space=external_matrix\n)\n</code></pre>"},{"location":"user-guide/distance-computation.html#expected-file-format","title":"Expected File Format","text":"<p>External distance files should contain:</p> <pre><code>{\n    \"source_task_ids\": [\"CHEMBL001\", \"CHEMBL002\", ...],    # or train_chembl_ids\n    \"target_task_ids\": [\"CHEMBL100\", \"CHEMBL101\", ...],    # or test_chembl_ids\n    \"distance_matrices\": numpy_array_or_tensor              # Shape: (n_targets, n_sources)\n}\n</code></pre>"},{"location":"user-guide/distance-computation.html#performance-optimization","title":"Performance Optimization","text":""},{"location":"user-guide/distance-computation.html#memory-management","title":"Memory Management","text":"<pre><code># Monitor memory usage\nimport psutil\nimport os\n\ndef check_memory():\n    process = psutil.Process(os.getpid())\n    memory_mb = process.memory_info().rss / 1024 / 1024\n    print(f\"Memory usage: {memory_mb:.1f} MB\")\n\ncheck_memory()\n\n# Compute distances in batches for large datasets\ndef compute_batched_distances(tasks, batch_size=100):\n    results = {}\n\n    for i in range(0, len(tasks), batch_size):\n        batch_tasks = tasks[i:i+batch_size]\n        batch_distance = MoleculeDatasetDistance(\n            tasks=batch_tasks,\n            molecule_method=\"euclidean\"  # Faster method\n        )\n        batch_results = batch_distance.get_distance()\n        results.update(batch_results)\n\n    return results\n</code></pre>"},{"location":"user-guide/distance-computation.html#computational-efficiency","title":"Computational Efficiency","text":"<pre><code># Choose methods based on dataset size\ndef choose_distance_method(num_molecules):\n    if num_molecules &lt; 1000:\n        return \"otdd\"           # Most accurate\n    elif num_molecules &lt; 10000:\n        return \"cosine\"         # Good balance\n    else:\n        return \"euclidean\"      # Fastest\n\n# Parallel computation for independent distances\nfrom concurrent.futures import ProcessPoolExecutor\n\ndef compute_parallel_distances(task_pairs):\n    def compute_single_distance(task_pair):\n        source_task, target_task = task_pair\n        distance_calc = MoleculeDatasetDistance(\n            tasks=[source_task, target_task],\n            molecule_method=\"euclidean\"\n        )\n        return distance_calc.get_distance()\n\n    with ProcessPoolExecutor() as executor:\n        results = list(executor.map(compute_single_distance, task_pairs))\n\n    return results\n</code></pre>"},{"location":"user-guide/distance-computation.html#gpu-acceleration","title":"GPU Acceleration","text":"<p>For OTDD computations with GPU support:</p> <pre><code>import torch\n\n# Check GPU availability\nif torch.cuda.is_available():\n    print(f\"GPU available: {torch.cuda.get_device_name()}\")\n\n    # OTDD will automatically use GPU if available\n    mol_distance = MoleculeDatasetDistance(\n        tasks=tasks,\n        molecule_method=\"otdd\"\n    )\n\n    # Monitor GPU memory\n    print(f\"GPU memory: {torch.cuda.memory_allocated() / 1024**2:.1f} MB\")\nelse:\n    print(\"Using CPU computation\")\n</code></pre>"},{"location":"user-guide/distance-computation.html#error-handling-and-debugging","title":"Error Handling and Debugging","text":""},{"location":"user-guide/distance-computation.html#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<pre><code>from themap.distance import DistanceComputationError, DataValidationError\n\ntry:\n    distances = mol_distance.get_distance()\nexcept ImportError as e:\n    print(f\"Missing dependencies: {e}\")\n    print(\"Install with: pip install -e '.[otdd]'\")\n\nexcept DistanceComputationError as e:\n    print(f\"Distance computation failed: {e}\")\n    # Fallback to simpler method\n    mol_distance.molecule_method = \"euclidean\"\n    distances = mol_distance.get_distance()\n\nexcept DataValidationError as e:\n    print(f\"Data validation failed: {e}\")\n    # Check data format and task IDs\n\nexcept torch.cuda.OutOfMemoryError:\n    print(\"GPU out of memory, falling back to CPU\")\n    torch.cuda.empty_cache()\n    # Reduce batch size or use CPU\n</code></pre>"},{"location":"user-guide/distance-computation.html#debugging-distance-computations","title":"Debugging Distance Computations","text":"<pre><code># Enable detailed logging\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Validate input data\ndef validate_distance_inputs(tasks):\n    print(f\"Number of tasks: {len(tasks)}\")\n\n    for i, task in enumerate(tasks[:3]):  # Check first 3 tasks\n        print(f\"Task {i}: {task.task_id}\")\n        if task.molecule_dataset:\n            print(f\"  Molecules: {len(task.molecule_dataset)}\")\n        if task.protein_dataset:\n            print(f\"  Proteins: {len(task.protein_dataset)}\")\n\n# Check feature computation\nsource_features, target_features, source_names, target_names = (\n    tasks.get_distance_computation_ready_features(\n        molecule_featurizer=\"ecfp\",\n        combination_method=\"concatenate\",\n        source_fold=\"TRAIN\",\n        target_folds=[\"TEST\"]\n    )\n)\n\nprint(f\"Source features: {len(source_features)} \u00d7 {len(source_features[0]) if source_features else 0}\")\nprint(f\"Target features: {len(target_features)} \u00d7 {len(target_features[0]) if target_features else 0}\")\nprint(f\"Source names: {source_names}\")\nprint(f\"Target names: {target_names}\")\n</code></pre>"},{"location":"user-guide/distance-computation.html#analysis-and-visualization","title":"Analysis and Visualization","text":""},{"location":"user-guide/distance-computation.html#converting-to-analysis-ready-formats","title":"Converting to Analysis-Ready Formats","text":"<pre><code># Convert to pandas DataFrame\ndf_distances = task_distance.to_pandas(\"molecule\")\nprint(df_distances.head())\n\n# Statistical analysis\nprint(f\"Mean distance: {df_distances.values.mean():.3f}\")\nprint(f\"Distance std: {df_distances.values.std():.3f}\")\n\n# Find most similar tasks\nmin_distance_idx = df_distances.values.argmin()\nrow, col = np.unravel_index(min_distance_idx, df_distances.shape)\nprint(f\"Most similar: {df_distances.index[row]} \u2194 {df_distances.columns[col]}\")\n</code></pre>"},{"location":"user-guide/distance-computation.html#visualization-examples","title":"Visualization Examples","text":"<pre><code>import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Distance matrix heatmap\nplt.figure(figsize=(10, 8))\nsns.heatmap(df_distances, annot=True, cmap='viridis', fmt='.2f')\nplt.title('Task Distance Matrix')\nplt.show()\n\n# Distance distribution\nplt.figure(figsize=(8, 6))\ndistances_flat = df_distances.values.flatten()\nplt.hist(distances_flat, bins=20, alpha=0.7)\nplt.xlabel('Distance')\nplt.ylabel('Frequency')\nplt.title('Distance Distribution')\nplt.show()\n\n# Hierarchical clustering\nfrom scipy.cluster.hierarchy import dendrogram, linkage\nfrom scipy.spatial.distance import squareform\n\n# Convert to condensed distance matrix\ncondensed_distances = squareform(df_distances.values)\nlinkage_matrix = linkage(condensed_distances, method='ward')\n\nplt.figure(figsize=(12, 8))\ndendrogram(linkage_matrix, labels=df_distances.index, orientation='top')\nplt.title('Task Similarity Dendrogram')\nplt.xticks(rotation=45)\nplt.show()\n</code></pre> <p>This comprehensive guide covers all aspects of distance computation in THEMAP. For specific use cases and advanced examples, see our tutorials and API documentation.</p>"},{"location":"user-guide/getting-started.html","title":"Getting Started","text":"<p>Welcome to THEMAP! This guide will help you get up and running with task hardness estimation for molecular activity prediction.</p>"},{"location":"user-guide/getting-started.html#what-is-themap","title":"What is THEMAP?","text":"<p>THEMAP (Task Hardness Estimation for Molecular Activity Prediction) is a Python library designed to aid drug discovery by providing powerful methods for estimating the difficulty of bioactivity prediction tasks. It enables researchers to:</p> <ul> <li>Compute distances between molecular datasets using various metrics (OTDD, Euclidean, Cosine)</li> <li>Analyze protein similarity through sequence and structural features</li> <li>Estimate task hardness for transfer learning scenarios</li> <li>Build transferability maps for bioactivity prediction tasks</li> <li>Integrate multi-modal data (molecules, proteins, metadata)</li> </ul>"},{"location":"user-guide/getting-started.html#installation","title":"Installation","text":""},{"location":"user-guide/getting-started.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>conda (recommended) or pip</li> </ul>"},{"location":"user-guide/getting-started.html#basic-installation","title":"Basic Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/HFooladi/THEMAP.git\ncd THEMAP\n\n# Create and activate conda environment\nconda env create -f environment.yml\nconda activate themap\n\n# Install THEMAP\npip install --no-deps -e .\n</code></pre>"},{"location":"user-guide/getting-started.html#installation-with-optional-dependencies","title":"Installation with Optional Dependencies","text":"<p>THEMAP has several optional dependency groups for different functionality:</p> <pre><code># For basic molecular analysis\npip install -e \".[ml]\"\n\n# For protein analysis\npip install -e \".[protein]\"\n\n# For OTDD distance computation\npip install -e \".[otdd]\"\n\n# For all features\npip install -e \".[all]\"\n\n# For development\npip install -e \".[dev,test]\"\n</code></pre>"},{"location":"user-guide/getting-started.html#verify-installation","title":"Verify Installation","text":"<pre><code>import themap\nprint(f\"THEMAP version: {themap.__version__}\")\n\n# Test basic functionality\nfrom themap import quick_distance\nprint(\"Installation successful!\")\n</code></pre>"},{"location":"user-guide/getting-started.html#quick-start","title":"Quick Start","text":""},{"location":"user-guide/getting-started.html#1-one-liner-distance-computation","title":"1. One-liner Distance Computation","text":"<p>The simplest way to compute distances between molecular datasets:</p> <pre><code>from themap import quick_distance\n\nresults = quick_distance(\n    data_dir=\"datasets\",          # Directory with train/ and test/ folders\n    output_dir=\"output\",          # Where to save results\n    molecule_featurizer=\"ecfp\",   # Fingerprint type (ecfp, maccs, etc.)\n    molecule_method=\"euclidean\",  # Distance metric\n)\n\n# Results saved to output/molecule_distances.csv\n</code></pre>"},{"location":"user-guide/getting-started.html#2-config-file-approach","title":"2. Config File Approach","text":"<p>For reproducible experiments, use a YAML configuration:</p> <pre><code>from themap import run_pipeline\n\nresults = run_pipeline(\"config.yaml\")\n</code></pre> <p>Example <code>config.yaml</code>: <pre><code>data:\n  directory: \"datasets\"\n\nmolecule:\n  enabled: true\n  featurizer: \"ecfp\"\n  method: \"euclidean\"\n\noutput:\n  directory: \"output\"\n  format: \"csv\"\n</code></pre></p>"},{"location":"user-guide/getting-started.html#3-analyzing-results","title":"3. Analyzing Results","text":"<pre><code>import pandas as pd\n\n# Load computed distances\ndistances = pd.read_csv(\"output/molecule_distances.csv\", index_col=0)\n\n# Find closest source for each target\nfor target in distances.columns:\n    closest = distances[target].idxmin()\n    dist = distances[target].min()\n    print(f\"{target} &lt;- {closest} (distance: {dist:.4f})\")\n\n# Estimate task hardness (average distance to k-nearest sources)\nk = 3\nfor target in distances.columns:\n    hardness = distances[target].nsmallest(k).mean()\n    print(f\"Task hardness for {target}: {hardness:.4f}\")\n</code></pre>"},{"location":"user-guide/getting-started.html#core-concepts","title":"Core Concepts","text":""},{"location":"user-guide/getting-started.html#tasks-and-data-modalities","title":"Tasks and Data Modalities","text":"<p>THEMAP organizes data around the concept of Tasks - individual bioactivity prediction problems that can contain:</p> <ul> <li>Molecular data: SMILES strings, molecular descriptors, embeddings</li> <li>Protein data: Sequences, structural features, embeddings</li> <li>Metadata: Assay descriptions, experimental conditions, bioactivity values</li> </ul>"},{"location":"user-guide/getting-started.html#distance-metrics","title":"Distance Metrics","text":"<p>Different distance metrics are optimized for different scenarios:</p> Method Use Case Pros Cons OTDD Comprehensive dataset comparison Most accurate, considers both features and labels Computationally expensive Euclidean Fast similarity estimation Fast, interpretable May miss complex relationships Cosine Feature orientation comparison Good for high-dimensional data Ignores magnitude differences"},{"location":"user-guide/getting-started.html#task-hardness","title":"Task Hardness","text":"<p>Task hardness quantifies how difficult a prediction task is, which helps in:</p> <ul> <li>Transfer learning: Identify similar tasks for knowledge transfer</li> <li>Model selection: Choose appropriate models based on task complexity</li> <li>Resource allocation: Prioritize difficult tasks for more computational resources</li> </ul>"},{"location":"user-guide/getting-started.html#directory-structure","title":"Directory Structure","text":"<p>Understanding the expected directory structure helps organize your data:</p> <pre><code>your_project/\n\u251c\u2500\u2500 datasets/\n\u2502   \u251c\u2500\u2500 train/\n\u2502   \u2502   \u251c\u2500\u2500 CHEMBL123.jsonl.gz    # Molecular data\n\u2502   \u2502   \u251c\u2500\u2500 CHEMBL123.fasta       # Protein sequences\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 test/\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 valid/\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 sample_tasks_list.json    # Task configuration\n\u251c\u2500\u2500 cache/                        # Feature caching\n\u2514\u2500\u2500 results/                      # Output analyses\n</code></pre>"},{"location":"user-guide/getting-started.html#sample-task-list-format","title":"Sample Task List Format","text":"<pre><code>{\n  \"train\": [\"CHEMBL1023359\", \"CHEMBL1613776\", ...],\n  \"test\": [\"CHEMBL2219358\", \"CHEMBL1963831\", ...],\n  \"valid\": [\"CHEMBL2219236\", ...]\n}\n</code></pre>"},{"location":"user-guide/getting-started.html#next-steps","title":"Next Steps","text":"<p>Now that you have the basics:</p> <ol> <li>Explore the tutorials: Check out detailed tutorials for step-by-step examples</li> <li>Explore the code: Understand the codebase structure for advanced usage</li> <li>Run the examples: Execute the provided example scripts</li> <li>Join the community: Contribute to the project on GitHub</li> </ol>"},{"location":"user-guide/getting-started.html#common-issues","title":"Common Issues","text":""},{"location":"user-guide/getting-started.html#import-errors","title":"Import Errors","text":"<p>If you encounter import errors:</p> <pre><code># Check if optional dependencies are installed\ntry:\n    from themap import quick_distance\n    print(\"Distance module available\")\nexcept ImportError as e:\n    print(f\"Missing dependencies: {e}\")\n    print(\"Install with: pip install -e '.[all]'\")\n</code></pre>"},{"location":"user-guide/getting-started.html#memory-issues","title":"Memory Issues","text":"<p>For large datasets, use faster distance methods:</p> <pre><code>from themap import quick_distance\n\n# Use euclidean instead of OTDD for large datasets\nresults = quick_distance(\n    data_dir=\"datasets\",\n    molecule_featurizer=\"ecfp\",\n    molecule_method=\"euclidean\",  # Faster than OTDD\n)\n</code></pre>"},{"location":"user-guide/getting-started.html#data-format-issues","title":"Data Format Issues","text":"<p>Ensure your data follows the expected format:</p> <pre><code>datasets/\n\u251c\u2500\u2500 train/\n\u2502   \u2514\u2500\u2500 CHEMBL123456.jsonl.gz\n\u2514\u2500\u2500 test/\n    \u2514\u2500\u2500 CHEMBL111111.jsonl.gz\n</code></pre> <p>Each <code>.jsonl.gz</code> file should contain JSON lines: <pre><code>{\"SMILES\": \"CCO\", \"Property\": 1}\n{\"SMILES\": \"CCCO\", \"Property\": 0}\n</code></pre></p> <p>Ready to dive deeper? Continue with our comprehensive tutorials!</p>"}]}